// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package NoteStore

import (
	"context"
	"fmt"
	"math"

	"github.com/apache/thrift/lib/go/thrift"

	"github.com/aliabdullahcp/evernote-golang-sdk/Errors"
	"github.com/aliabdullahcp/evernote-golang-sdk/Limits"
	"github.com/aliabdullahcp/evernote-golang-sdk/Types"
	"github.com/aliabdullahcp/evernote-golang-sdk/UserStore"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

var _ = UserStore.GoUnusedProtection__
var _ = Types.GoUnusedProtection__
var _ = Errors.GoUnusedProtection__
var _ = Limits.GoUnusedProtection__

type NoteStore interface {
	// Asks the NoteStore to provide information about the status of the user
	// account corresponding to the provided authentication token.
	//
	// Parameters:
	//  - AuthenticationToken
	GetSyncState(ctx context.Context, authenticationToken string) (r *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Asks the NoteStore to provide information about the status of the user
	// account corresponding to the provided authentication token.
	// This version of 'getSyncState' allows the client to upload coarse-
	// grained usage metrics to the service.
	//
	// @param clientMetrics  see the documentation of the ClientUsageMetrics
	//   structure for an explanation of the fields that clients can pass to
	//   the service.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - ClientMetrics
	GetSyncStateWithMetrics(ctx context.Context, authenticationToken string, clientMetrics *ClientUsageMetrics) (r *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// DEPRECATED - use getFilteredSyncChunk.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - AfterUSN
	//  - MaxEntries
	//  - FullSyncOnly
	GetSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, fullSyncOnly bool) (r *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Asks the NoteStore to provide the state of the account in order of
	// last modification.  This request retrieves one block of the server's
	// state so that a client can make several small requests against a large
	// account rather than getting the entire state in one big message.
	// This call gives fine-grained control of the data that will
	// be received by a client by omitting data elements that a client doesn't
	// need. This may reduce network traffic and sync times.
	//
	// @param afterUSN
	//   The client can pass this value to ask only for objects that
	//   have been updated after a certain point.  This allows the client to
	//   receive updates after its last checkpoint rather than doing a full
	//   synchronization on every pass.  The default value of "0" indicates
	//   that the client wants to get objects from the start of the account.
	//
	// @param maxEntries
	//   The maximum number of modified objects that should be
	//   returned in the result SyncChunk.  This can be used to limit the size
	//   of each individual message to be friendly for network transfer.
	//
	// @param filter
	//   The caller must set some of the flags in this structure to specify which
	//   data types should be returned during the synchronization.  See
	//   the SyncChunkFilter structure for information on each flag.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "afterUSN" - if negative
	//   </li>
	//   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - AfterUSN
	//  - MaxEntries
	//  - Filter
	GetFilteredSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, filter *SyncChunkFilter) (r *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Asks the NoteStore to provide information about the status of a linked
	// notebook that has been shared with the caller, or that is public to the
	// world.
	// This will return a result that is similar to getSyncState, but may omit
	// SyncState.uploaded if the caller doesn't have permission to write to
	// the linked notebook.
	//
	// This function must be called on the shard that owns the referenced
	// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
	// same as LinkedNotebook.shardId.)
	//
	// @param authenticationToken
	//   This should be an authenticationToken for the guest who has received
	//   the invitation to the share.  (I.e. this should not be the result of
	//   NoteStore.authenticateToSharedNotebook)
	//
	// @param linkedNotebook
	//   This structure should contain identifying information and permissions
	//   to access the notebook in question.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - LinkedNotebook
	GetLinkedNotebookSyncState(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (r *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Asks the NoteStore to provide information about the contents of a linked
	// notebook that has been shared with the caller, or that is public to the
	// world.
	// This will return a result that is similar to getSyncChunk, but will only
	// contain entries that are visible to the caller.  I.e. only that particular
	// Notebook will be visible, along with its Notes, and Tags on those Notes.
	//
	// This function must be called on the shard that owns the referenced
	// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
	// same as LinkedNotebook.shardId.)
	//
	// @param authenticationToken
	//   This should be an authenticationToken for the guest who has received
	//   the invitation to the share.  (I.e. this should not be the result of
	//   NoteStore.authenticateToSharedNotebook)
	//
	// @param linkedNotebook
	//   This structure should contain identifying information and permissions
	//   to access the notebook in question.  This must contain the valid fields
	//   for either a shared notebook (e.g. shareKey)
	//   or a public notebook (e.g. username, uri)
	//
	// @param afterUSN
	//   The client can pass this value to ask only for objects that
	//   have been updated after a certain point.  This allows the client to
	//   receive updates after its last checkpoint rather than doing a full
	//   synchronization on every pass.  The default value of "0" indicates
	//   that the client wants to get objects from the start of the account.
	//
	// @param maxEntries
	//   The maximum number of modified objects that should be
	//   returned in the result SyncChunk.  This can be used to limit the size
	//   of each individual message to be friendly for network transfer.
	//   Applications should not request more than 256 objects at a time,
	//   and must handle the case where the service returns less than the
	//   requested number of objects in a given request even though more
	//   objects are available on the service.
	//
	// @param fullSyncOnly
	//   If true, then the client only wants initial data for a full sync.
	//   In this case, the service will not return any expunged objects,
	//   and will not return any Resources, since these are also provided
	//   in their corresponding Notes.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "afterUSN" - if negative
	//   </li>
	//   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "LinkedNotebook" - if the provided information doesn't match any
	//     valid notebook
	//   </li>
	//   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
	//     valid notebook
	//   </li>
	//   <li> "SharedNotebook.id" - if the provided information indicates a
	//      shared notebook that no longer exists
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - LinkedNotebook
	//  - AfterUSN
	//  - MaxEntries
	//  - FullSyncOnly
	GetLinkedNotebookSyncChunk(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook, afterUSN int32, maxEntries int32, fullSyncOnly bool) (r *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns a list of all of the notebooks in the account.
	//
	// Parameters:
	//  - AuthenticationToken
	ListNotebooks(ctx context.Context, authenticationToken string) (r []*Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Returns the current state of the notebook with the provided GUID.
	// The notebook may be active or deleted (but not expunged).
	//
	// @param guid
	//   The GUID of the notebook to be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - tag not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns the notebook that should be used to store new notes in the
	// user's account when no other notebooks are specified.
	//
	// Parameters:
	//  - AuthenticationToken
	GetDefaultNotebook(ctx context.Context, authenticationToken string) (r *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Asks the service to make a notebook with the provided name.
	//
	// @param notebook
	//   The desired fields for the notebook must be provided on this
	//   object.  The name of the notebook must be set, and either the 'active'
	//   or 'defaultNotebook' fields may be set by the client at creation.
	//   If a notebook exists in the account with the same name (via
	//   case-insensitive compare), this will throw an EDAMUserException.
	//
	// @return
	//   The newly created Notebook.  The server-side GUID will be
	//   saved in this object's 'guid' field.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
	//   </li>
	//   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
	//   </li>
	//   <li> DATA_CONFLICT "Notebook.name" - name already in use
	//   </li>
	//   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
	//   </li>
	//   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
	//   </li>
	//   <li> LIMIT_REACHED "Notebook" - at max number of notebooks
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Notebook
	CreateNotebook(ctx context.Context, authenticationToken string, notebook *Types.Notebook) (r *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Submits notebook changes to the service.  The provided data must include
	// the notebook's guid field for identification.
	//
	// @param notebook
	//   The notebook object containing the requested changes.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
	//   </li>
	//   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
	//   </li>
	//   <li> DATA_CONFLICT "Notebook.name" - name already in use
	//   </li>
	//   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
	//   </li>
	//   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Notebook
	UpdateNotebook(ctx context.Context, authenticationToken string, notebook *Types.Notebook) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Permanently removes the notebook from the user's account.
	// After this action, the notebook is no longer available for undeletion, etc.
	// If the notebook contains any Notes, they will be moved to the current
	// default notebook and moved into the trash (i.e. Note.active=false).
	// <p/>
	// NOTE: This function is generally not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param guid
	//   The GUID of the notebook to delete.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
	//   </li>
	//   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
	//   </li>
	//   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	ExpungeNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns a list of the tags in the account.  Evernote does not support
	// the undeletion of tags, so this will only include active tags.
	//
	// Parameters:
	//  - AuthenticationToken
	ListTags(ctx context.Context, authenticationToken string) (r []*Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Returns a list of the tags that are applied to at least one note within
	// the provided notebook.  If the notebook is public, the authenticationToken
	// may be ignored.
	//
	// @param notebookGuid
	//    the GUID of the notebook to use to find tags
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - notebook not found by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - NotebookGuid
	ListTagsByNotebook(ctx context.Context, authenticationToken string, notebookGuid Types.Guid) (r []*Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns the current state of the Tag with the provided GUID.
	//
	// @param guid
	//   The GUID of the tag to be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Tag.guid" - tag not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetTag(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Asks the service to make a tag with a set of information.
	//
	// @param tag
	//   The desired list of fields for the tag are specified in this
	//   object.  The caller must specify the tag name, and may provide
	//   the parentGUID.
	//
	// @return
	//   The newly created Tag.  The server-side GUID will be
	//   saved in this object.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
	//   </li>
	//   <li> DATA_CONFLICT "Tag.name" - name already in use
	//   </li>
	//   <li> LIMIT_REACHED "Tag" - at max number of tags
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Tag.parentGuid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Tag
	CreateTag(ctx context.Context, authenticationToken string, tag *Types.Tag) (r *Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Submits tag changes to the service.  The provided data must include
	// the tag's guid field for identification.  The service will apply
	// updates to the following tag fields:  name, parentGuid
	//
	// @param tag
	//   The tag object containing the requested changes.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
	//   </li>
	//   <li> DATA_CONFLICT "Tag.name" - name already in use
	//   </li>
	//   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
	//   </li>
	//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Tag.guid" - tag not found, by GUID
	//   </li>
	//   <li> "Tag.parentGuid" - parent not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Tag
	UpdateTag(ctx context.Context, authenticationToken string, tag *Types.Tag) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Removes the provided tag from every note that is currently tagged with
	// this tag.  If this operation is successful, the tag will still be in
	// the account, but it will not be tagged on any notes.
	//
	// This function is not indended for use by full synchronizing clients, since
	// it does not provide enough result information to the client to reconcile
	// the local state without performing a follow-up sync from the service.  This
	// is intended for "thin clients" that need to efficiently support this as
	// a UI operation.
	//
	// @param guid
	//   The GUID of the tag to remove from all notes.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Tag.guid" - tag not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	UntagAll(ctx context.Context, authenticationToken string, guid Types.Guid) (userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Permanently deletes the tag with the provided GUID, if present.
	// <p/>
	// NOTE: This function is generally not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param guid
	//   The GUID of the tag to delete.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Tag.guid" - tag not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	ExpungeTag(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns a list of the searches in the account.  Evernote does not support
	// the undeletion of searches, so this will only include active searches.
	//
	// Parameters:
	//  - AuthenticationToken
	ListSearches(ctx context.Context, authenticationToken string) (r []*Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Returns the current state of the search with the provided GUID.
	//
	// @param guid
	//   The GUID of the search to be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
	//   </li>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "SavedSearch.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetSearch(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Asks the service to make a saved search with a set of information.
	//
	// @param search
	//   The desired list of fields for the search are specified in this
	//   object. The caller must specify the name and query for the
	//   search, and may optionally specify a search scope.
	//   The SavedSearch.format field is ignored by the service.
	//
	// @return
	//   The newly created SavedSearch.  The server-side GUID will be
	//   saved in this object.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
	//   </li>
	//   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
	//   </li>
	//   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Search
	CreateSearch(ctx context.Context, authenticationToken string, search *Types.SavedSearch) (r *Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Submits search changes to the service. The provided data must include
	// the search's guid field for identification. The service will apply
	// updates to the following search fields: name, query, and scope.
	//
	// @param search
	//   The search object containing the requested changes.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
	//   </li>
	//   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
	//   </li>
	//   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "SavedSearch.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Search
	UpdateSearch(ctx context.Context, authenticationToken string, search *Types.SavedSearch) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Permanently deletes the saved search with the provided GUID, if present.
	// <p/>
	// NOTE: This function is generally not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param guid
	//   The GUID of the search to delete.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
	//   </li>
	//   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "SavedSearch.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	ExpungeSearch(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// DEPRECATED. Use findNotesMetadata.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Filter
	//  - Offset
	//  - MaxNotes
	FindNotes(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32) (r *NoteList, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Finds the position of a note within a sorted subset of all of the user's
	// notes. This may be useful for thin clients that are displaying a paginated
	// listing of a large account, which need to know where a particular note
	// sits in the list without retrieving all notes first.
	//
	// @param authenticationToken
	//   Must be a valid token for the user's account unless the NoteFilter
	//   'notebookGuid' is the GUID of a public notebook.
	//
	// @param filter
	//   The list of criteria that will constrain the notes to be returned.
	//
	// @param guid
	//   The GUID of the note to be retrieved.
	//
	// @return
	//   If the note with the provided GUID is found within the matching note
	//   list, this will return the offset of that note within that list (where
	//   the first offset is 0).  If the note is not found within the set of
	//   notes, this will return -1.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
	//   </li>
	//   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
	//   </li>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - not found, by GUID
	//   </li>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Filter
	//  - Guid
	FindNoteOffset(ctx context.Context, authenticationToken string, filter *NoteFilter, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Used to find the high-level information about a set of the notes from a
	// user's account based on various criteria specified via a NoteFilter object.
	// <p/>
	// Web applications that wish to periodically check for new content in a user's
	// Evernote account should consider using webhooks instead of polling this API.
	// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
	// for more information.
	//
	// @param authenticationToken
	//   Must be a valid token for the user's account unless the NoteFilter
	//   'notebookGuid' is the GUID of a public notebook.
	//
	// @param filter
	//   The list of criteria that will constrain the notes to be returned.
	//
	// @param offset
	//   The numeric index of the first note to show within the sorted
	//   results.  The numbering scheme starts with "0".  This can be used for
	//   pagination.
	//
	// @param maxNotes
	//   The mximum notes to return in this query.  The service will return a set
	//   of notes that is no larger than this number, but may return fewer notes
	//   if needed.  The NoteList.totalNotes field in the return value will
	//   indicate whether there are more values available after the returned set.
	//
	// @param resultSpec
	//   This specifies which information should be returned for each matching
	//   Note. The fields on this structure can be used to eliminate data that
	//   the client doesn't need, which will reduce the time and bandwidth
	//   to receive and process the reply.
	//
	// @return
	//   The list of notes that match the criteria.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
	//   </li>
	//   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Filter
	//  - Offset
	//  - MaxNotes
	//  - ResultSpec
	FindNotesMetadata(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32, resultSpec *NotesMetadataResultSpec) (r *NotesMetadataList, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// This function is used to determine how many notes are found for each
	// notebook and tag in the user's account, given a current set of filter
	// parameters that determine the current selection.  This function will
	// return a structure that gives the note count for each notebook and tag
	// that has at least one note under the requested filter.  Any notebook or
	// tag that has zero notes in the filtered set will not be listed in the
	// reply to this function (so they can be assumed to be 0).
	//
	// @param authenticationToken
	//   Must be a valid token for the user's account unless the NoteFilter
	//   'notebookGuid' is the GUID of a public notebook.
	//
	// @param filter
	//   The note selection filter that is currently being applied.  The note
	//   counts are to be calculated with this filter applied to the total set
	//   of notes in the user's account.
	//
	// @param withTrash
	//   If true, then the NoteCollectionCounts.trashCount will be calculated
	//   and supplied in the reply. Otherwise, the trash value will be omitted.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
	//   </li>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Filter
	//  - WithTrash
	FindNoteCounts(ctx context.Context, authenticationToken string, filter *NoteFilter, withTrash bool) (r *NoteCollectionCounts, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns the current state of the note in the service with the provided
	// GUID.  The ENML contents of the note will only be provided if the
	// 'withContent' parameter is true.  The service will include the meta-data
	// for each resource in the note, but the binary contents of the resources
	// and their recognition data will be omitted.
	// If the Note is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).  The applicationData
	// fields are returned as keysOnly.
	//
	// @param guid
	//   The GUID of the note to be retrieved.
	//
	// @param withContent
	//   If true, the note will include the ENML contents of its
	//   'content' field.
	//
	// @param withResourcesData
	//   If true, any Resource elements in this Note will include the binary
	//   contents of their 'data' field's body.
	//
	// @param withResourcesRecognition
	//   If true, any Resource elements will include the binary contents of the
	//   'recognition' field's body if recognition data is present.
	//
	// @param withResourcesAlternateData
	//   If true, any Resource elements in this Note will include the binary
	//   contents of their 'alternateData' fields' body, if an alternate form
	//   is present.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - WithContent
	//  - WithResourcesData
	//  - WithResourcesRecognition
	//  - WithResourcesAlternateData
	GetNote(ctx context.Context, authenticationToken string, guid Types.Guid, withContent bool, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Get all of the application data for the note identified by GUID,
	// with values returned within the LazyMap fullMap field.
	// If there are no applicationData entries, then a LazyMap
	// with an empty fullMap will be returned. If your application
	// only needs to fetch its own applicationData entry, use
	// getNoteApplicationDataEntry instead.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetNoteApplicationData(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.LazyMap, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Get the value of a single entry in the applicationData map
	// for the note identified by GUID.
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - note not found, by GUID</li>
	//   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - Key
	GetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Update, or create, an entry in the applicationData map for
	// the note identified by guid.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - Key
	//  - Value
	SetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string, value string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Remove an entry identified by 'key' from the applicationData map for
	// the note identified by 'guid'. Silently ignores an unset of a
	// non-existing key.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - Key
	UnsetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns XHTML contents of the note with the provided GUID.
	// If the Note is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).
	//
	// @param guid
	//   The GUID of the note to be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetNoteContent(ctx context.Context, authenticationToken string, guid Types.Guid) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns a block of the extracted plain text contents of the note with the
	// provided GUID.  This text can be indexed for search purposes by a light
	// client that doesn't have capabilities to extract all of the searchable
	// text content from the note and its resources.
	//
	// If the Note is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).
	//
	// @param guid
	//   The GUID of the note to be retrieved.
	//
	// @param noteOnly
	//   If true, this will only return the text extracted from the ENML contents
	//   of the note itself.  If false, this will also include the extracted text
	//   from any text-bearing resources (PDF, recognized images)
	//
	// @param tokenizeForIndexing
	//   If true, this will break the text into cleanly separated and sanitized
	//   tokens.  If false, this will return the more raw text extraction, with
	//   its original punctuation, capitalization, spacing, etc.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - NoteOnly
	//  - TokenizeForIndexing
	GetNoteSearchText(ctx context.Context, authenticationToken string, guid Types.Guid, noteOnly bool, tokenizeForIndexing bool) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns a block of the extracted plain text contents of the resource with
	// the provided GUID.  This text can be indexed for search purposes by a light
	// client that doesn't have capability to extract all of the searchable
	// text content from a resource.
	//
	// If the Resource is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).
	//
	// @param guid
	//   The GUID of the resource to be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetResourceSearchText(ctx context.Context, authenticationToken string, guid Types.Guid) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns a list of the names of the tags for the note with the provided
	// guid.  This can be used with authentication to get the tags for a
	// user's own note, or can be used without valid authentication to retrieve
	// the names of the tags for a note in a public notebook.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetNoteTagNames(ctx context.Context, authenticationToken string, guid Types.Guid) (r []string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Asks the service to make a note with the provided set of information.
	//
	// @param note
	//   A Note object containing the desired fields to be populated on
	//   the service.
	//
	// @return
	//   The newly created Note from the service.  The server-side
	//   GUIDs for the Note and any Resources will be saved in this object.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
	//   </li>
	//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
	//   </li>
	//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
	//   </li>
	//   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
	//   </li>
	//   <li> DATA_REQUIRED "Resource.data" - resource data body missing
	//   </li>
	//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
	//   </li>
	//   <li> LIMIT_REACHED "Note" - at max number per account
	//   </li>
	//   <li> LIMIT_REACHED "Note.size" - total note size too large
	//   </li>
	//   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
	//   </li>
	//   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
	//   </li>
	//   <li> LIMIT_REACHED "Resource.data.size" - resource too large
	//   </li>
	//   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
	//   </li>
	//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
	//   </li>
	//   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
	//   </li>
	//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
	//   </li>
	//   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
	//     of the specified tags had an invalid length or pattern
	//   </li>
	//   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
	//     new tags would exceed the maximum number per account
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.notebookGuid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Note
	CreateNote(ctx context.Context, authenticationToken string, note *Types.Note) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Submit a set of changes to a note to the service.  The provided data
	// must include the note's guid field for identification. The note's
	// title must also be set.
	//
	// @param note
	//   A Note object containing the desired fields to be populated on
	//   the service. With the exception of the note's title and guid, fields
	//   that are not being changed do not need to be set. If the content is not
	//   being modified, note.content should be left unset. If the list of
	//   resources is not being modified, note.resources should be left unset.
	//
	// @return
	//   The metadata (no contents) for the Note on the server after the update
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
	//   </li>
	//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
	//   </li>
	//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
	//   </li>
	//   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
	//   </li>
	//   <li> DATA_REQUIRED "Resource.data" - resource data body missing
	//   </li>
	//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
	//   </li>
	//   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
	//   </li>
	//   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
	//   </li>
	//   <li> LIMIT_REACHED "Note.size" - total note size too large
	//   </li>
	//   <li> LIMIT_REACHED "Resource.data.size" - resource too large
	//   </li>
	//   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
	//   </li>
	//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - user doesn't own
	//   </li>
	//   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
	//   </li>
	//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
	//   </li>
	//   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
	//     of the specified tags had an invalid length or pattern
	//   </li>
	//   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
	//     new tags would exceed the maximum number per account
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - note not found, by GUID
	//   </li>
	//   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Note
	UpdateNote(ctx context.Context, authenticationToken string, note *Types.Note) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Moves the note into the trash. The note may still be undeleted, unless it
	// is expunged.  This is equivalent to calling updateNote() after setting
	// Note.active = false
	//
	// @param guid
	//   The GUID of the note to delete.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
	//          update the note.
	//   </li>
	// </ul>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
	//   </li>
	// </ul>
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	DeleteNote(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Permanently removes a Note, and all of its Resources,
	// from the service.
	// <p/>
	// NOTE: This function is not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param guid
	//   The GUID of the note to delete.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "Note" - user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	ExpungeNote(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Permanently removes a list of Notes, and all of their Resources, from
	// the service.  This should be invoked with a small number of Note GUIDs
	// (e.g. 100 or less) on each call.  To expunge a larger number of notes,
	// call this method multiple times.  This should also be used to reduce the
	// number of Notes in a notebook before calling expungeNotebook(ctx) or
	// in the trash before calling expungeInactiveNotes(ctx), since these calls may
	// be prohibitively slow if there are more than a few hundred notes.
	// If an exception is thrown for any of the GUIDs, then none of the notes
	// will be deleted.  I.e. this call can be treated as an atomic transaction.
	// <p/>
	// NOTE: This function is not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param noteGuids
	//   The list of GUIDs for the Notes to remove.
	//
	// @return
	//   The account's updateCount at the end of this operation
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "Note" - user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - NoteGuids
	ExpungeNotes(ctx context.Context, authenticationToken string, noteGuids []Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Permanently removes all of the Notes that are currently marked as
	// inactive.  This is equivalent to "emptying the trash", and these Notes
	// will be gone permanently.
	// <p/>
	// This operation may be relatively slow if the account contains a large
	// number of inactive Notes.
	// <p/>
	// NOTE: This function is not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @return
	//    The number of notes that were expunged.
	//
	// Parameters:
	//  - AuthenticationToken
	ExpungeInactiveNotes(ctx context.Context, authenticationToken string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
	// the Notebook with the provided GUID 'toNotebookGuid'.
	// The caller must be the owner of both the Note and the Notebook.
	// This creates a new Note in the destination Notebook with new content and
	// Resources that match all of the content and Resources from the original
	// Note, but with new GUID identifiers.
	// The original Note is not modified by this operation.
	// The copied note is considered as an "upload" for the purpose of upload
	// transfer limit calculation, so its size is added to the upload count for
	// the owner.
	//
	// @param noteGuid
	//   The GUID of the Note to copy.
	//
	// @param toNotebookGuid
	//   The GUID of the Notebook that should receive the new Note.
	//
	// @return
	//   The metadata for the new Note that was created.  This will include the
	//   new GUID for this Note (and any copied Resources), but will not include
	//   the content body or the binary bodies of any Resources.
	//
	// @throws EDAMUserException <ul>
	//   <li> LIMIT_REACHED "Note" - at max number per account
	//   </li>
	//   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - user doesn't own
	//   </li>
	//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - NoteGuid
	//  - ToNotebookGuid
	CopyNote(ctx context.Context, authenticationToken string, noteGuid Types.Guid, toNotebookGuid Types.Guid) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns a list of the prior versions of a particular note that are
	// saved within the service.  These prior versions are stored to provide a
	// recovery from unintentional removal of content from a note. The identifiers
	// that are returned by this call can be used with getNoteVersion to retrieve
	// the previous note.
	// The identifiers will be listed from the most recent versions to the oldest.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - NoteGuid
	ListNoteVersions(ctx context.Context, authenticationToken string, noteGuid Types.Guid) (r []*NoteVersionId, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// This can be used to retrieve a previous version of a Note after it has been
	// updated within the service.  The caller must identify the note (via its
	// guid) and the version (via the updateSequenceNumber of that version).
	// to find a listing of the stored version USNs for a note, call
	// listNoteVersions.
	// This call is only available for notes in Premium accounts.  (I.e. access
	// to past versions of Notes is a Premium-only feature.)
	//
	// @param noteGuid
	//   The GUID of the note to be retrieved.
	//
	// @param updateSequenceNum
	//   The USN of the version of the note that is being retrieved
	//
	// @param withResourcesData
	//   If true, any Resource elements in this Note will include the binary
	//   contents of their 'data' field's body.
	//
	// @param withResourcesRecognition
	//   If true, any Resource elements will include the binary contents of the
	//   'recognition' field's body if recognition data is present.
	//
	// @param withResourcesAlternateData
	//   If true, any Resource elements in this Note will include the binary
	//   contents of their 'alternateData' fields' body, if an alternate form
	//   is present.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	//   <li> PERMISSION_DENIED "updateSequenceNum" -
	//     The account isn't permitted to access previous versions of notes.
	//     (i.e. this is a Free account.)
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	//   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
	//      the corresponding USN.
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - NoteGuid
	//  - UpdateSequenceNum
	//  - WithResourcesData
	//  - WithResourcesRecognition
	//  - WithResourcesAlternateData
	GetNoteVersion(ctx context.Context, authenticationToken string, noteGuid Types.Guid, updateSequenceNum int32, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns the current state of the resource in the service with the
	// provided GUID.
	// If the Resource is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).  Only the
	// keys for the applicationData will be returned.
	//
	// @param guid
	//   The GUID of the resource to be retrieved.
	//
	// @param withData
	//   If true, the Resource will include the binary contents of the
	//   'data' field's body.
	//
	// @param withRecognition
	//   If true, the Resource will include the binary contents of the
	//   'recognition' field's body if recognition data is present.
	//
	// @param withAttributes
	//   If true, the Resource will include the attributes
	//
	// @param withAlternateData
	//   If true, the Resource will include the binary contents of the
	//   'alternateData' field's body, if an alternate form is present.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - WithData
	//  - WithRecognition
	//  - WithAttributes
	//  - WithAlternateData
	GetResource(ctx context.Context, authenticationToken string, guid Types.Guid, withData bool, withRecognition bool, withAttributes bool, withAlternateData bool) (r *Types.Resource, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Get all of the application data for the Resource identified by GUID,
	// with values returned within the LazyMap fullMap field.
	// If there are no applicationData entries, then a LazyMap
	// with an empty fullMap will be returned. If your application
	// only needs to fetch its own applicationData entry, use
	// getResourceApplicationDataEntry instead.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetResourceApplicationData(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.LazyMap, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Get the value of a single entry in the applicationData map
	// for the Resource identified by GUID.
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - Resource not found, by GUID</li>
	//   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - Key
	GetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Update, or create, an entry in the applicationData map for
	// the Resource identified by guid.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - Key
	//  - Value
	SetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string, value string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Remove an entry identified by 'key' from the applicationData map for
	// the Resource identified by 'guid'.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	//  - Key
	UnsetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Submit a set of changes to a resource to the service.  This can be used
	// to update the meta-data about the resource, but cannot be used to change
	// the binary contents of the resource (including the length and hash).  These
	// cannot be changed directly without creating a new resource and removing the
	// old one via updateNote.
	//
	// @param resource
	//   A Resource object containing the desired fields to be populated on
	//   the service.  The service will attempt to update the resource with the
	//   following fields from the client:
	//   <ul>
	//      <li>guid:  must be provided to identify the resource
	//      </li>
	//      <li>mime
	//      </li>
	//      <li>width
	//      </li>
	//      <li>height
	//      </li>
	//      <li>duration
	//      </li>
	//      <li>attributes:  optional.  if present, the set of attributes will
	//           be replaced.
	//      </li>
	//   </ul>
	//
	// @return
	//   The Update Sequence Number of the resource after the changes have been
	//   applied.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
	//   </li>
	//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
	//   </li>
	//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
	//   </li>
	//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Resource
	UpdateResource(ctx context.Context, authenticationToken string, resource *Types.Resource) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns binary data of the resource with the provided GUID.  For
	// example, if this were an image resource, this would contain the
	// raw bits of the image.
	// If the Resource is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).
	//
	// @param guid
	//   The GUID of the resource to be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetResourceData(ctx context.Context, authenticationToken string, guid Types.Guid) (r []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns the current state of a resource, referenced by containing
	// note GUID and resource content hash.
	//
	// @param noteGuid
	//   The GUID of the note that holds the resource to be retrieved.
	//
	// @param contentHash
	//   The MD5 checksum of the resource within that note. Note that
	//   this is the binary checksum, for example from Resource.data.bodyHash,
	//   and not the hex-encoded checksum that is used within an en-media
	//   tag in a note body.
	//
	// @param withData
	//   If true, the Resource will include the binary contents of the
	//   'data' field's body.
	//
	// @param withRecognition
	//   If true, the Resource will include the binary contents of the
	//   'recognition' field's body.
	//
	// @param withAlternateData
	//   If true, the Resource will include the binary contents of the
	//   'alternateData' field's body, if an alternate form is present.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
	//   </li>
	//   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note" - not found, by guid
	//   </li>
	//   <li> "Resource" - not found, by hash
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - NoteGuid
	//  - ContentHash
	//  - WithData
	//  - WithRecognition
	//  - WithAlternateData
	GetResourceByHash(ctx context.Context, authenticationToken string, noteGuid Types.Guid, contentHash []byte, withData bool, withRecognition bool, withAlternateData bool) (r *Types.Resource, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns the binary contents of the recognition index for the resource
	// with the provided GUID.  If the caller asks about a resource that has
	// no recognition data, this will throw EDAMNotFoundException.
	// If the Resource is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).
	//
	// @param guid
	//   The GUID of the resource whose recognition data should be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - not found, by GUID
	//   </li>
	//   <li> "Resource.recognition" - resource has no recognition
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetResourceRecognition(ctx context.Context, authenticationToken string, guid Types.Guid) (r []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// If the Resource with the provided GUID has an alternate data representation
	// (indicated via the Resource.alternateData field), then this request can
	// be used to retrieve the binary contents of that alternate data file.
	// If the caller asks about a resource that has no alternate data form, this
	// will throw EDAMNotFoundException.
	//
	// @param guid
	//    The GUID of the resource whose recognition data should be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - not found, by GUID
	//   </li>
	//   <li> "Resource.alternateData" - resource has no recognition
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetResourceAlternateData(ctx context.Context, authenticationToken string, guid Types.Guid) (r []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Returns the set of attributes for the Resource with the provided GUID.
	// If the Resource is found in a public notebook, the authenticationToken
	// will be ignored (so it could be an empty string).
	//
	// @param guid
	//   The GUID of the resource whose attributes should be retrieved.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Resource.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	GetResourceAttributes(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.ResourceAttributes, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// <p>
	// Looks for a user account with the provided userId on this NoteStore
	// shard and determines whether that account contains a public notebook
	// with the given URI.  If the account is not found, or no public notebook
	// exists with this URI, this will throw an EDAMNotFoundException,
	// otherwise this will return the information for that Notebook.
	// </p>
	// <p>
	// If a notebook is visible on the web with a full URL like
	// http://www.evernote.com/pub/sethdemo/api
	// Then 'sethdemo' is the username that can be used to look up the userId,
	// and 'api' is the publicUri.
	// </p>
	//
	// @param userId
	//    The numeric identifier for the user who owns the public notebook.
	//    To find this value based on a username string, you can invoke
	//    UserStore.getPublicUserInfo
	//
	// @param publicUri
	//    The uri string for the public notebook, from Notebook.publishing.uri.
	//
	// @throws EDAMNotFoundException <ul>
	//   <li>"Publishing.uri" - not found, by URI</li>
	// </ul>
	//
	// @throws EDAMSystemException <ul>
	//   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
	//     taken down (for all requesters).</li>
	//   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
	//     down for the requester because of an IP-based country lookup.</li>
	// </ul>
	//
	// Parameters:
	//  - UserId
	//  - PublicUri
	GetPublicNotebook(ctx context.Context, userId Types.UserID, publicUri string) (r *Types.Notebook, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
	// Used to construct a shared notebook object. The constructed notebook will
	// contain a "share key" which serve as a unique identifer and access token
	// for a user to access the notebook of the shared notebook owner.
	//
	// @param sharedNotebook
	//   A shared notebook object populated with the email address of the share
	//   recipient, the notebook guid and the access permissions. All other
	//   attributes of the shared object are ignored. The SharedNotebook.allowPreview
	//   field must be explicitly set with either a true or false value.
	//
	// @return
	//   The fully populated SharedNotebook object including the server assigned
	//   share id and shareKey which can both be used to uniquely identify the
	//   SharedNotebook.
	//
	// @throws EDAMUserException <ul>
	//   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
	//   <li>BAD_DATA_FORMAT "requireLogin" - if the SharedNotebook.allowPreview field was
	//       not set, and the SharedNotebook.requireLogin was also not set or was set to
	//       false.</li>
	//   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
	//       recipientSettings is set in the sharedNotebook.  Only the recipient
	//       can set these values via the setSharedNotebookRecipientSettings
	//       method.
	//   </li>
	//   </ul>
	// @throws EDAMNotFoundException <ul>
	//   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
	//   </li>
	//   </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - SharedNotebook
	CreateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *Types.SharedNotebook) (r *Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Update a SharedNotebook object.
	//
	// @param authenticationToken
	//   Must be an authentication token from the owner or a shared notebook
	//   authentication token or business authentication token with sufficient
	//   permissions to change invitations for a notebook.
	//
	// @param sharedNotebook
	//  The SharedNotebook object containing the requested changes.
	//  The "id" of the shared notebook must be set to allow the service
	//  to identify the SharedNotebook to be updated. In addition, you MUST set
	//  the email, permission, and allowPreview fields to the desired values.
	//  All other fields will be ignored if set.
	//
	// @return
	//  The Update Serial Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li>UNSUPPORTED_OPERATION "updateSharedNotebook" - if this service instance does not support shared notebooks.</li>
	//   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid.</li>
	//   <li>DATA_REQUIRED "SharedNotebook.id" - if the id field was not set.</li>
	//   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the privilege field was not set.</li>
	//   <li>DATA_REQUIRED "SharedNotebook.allowPreview" - if the allowPreview field was not set.</li>
	//   </ul>
	// @throws EDAMNotFoundException <ul>
	//   <li>SharedNotebook.id - if no shared notebook with the specified ID was found.
	//   </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - SharedNotebook
	UpdateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *Types.SharedNotebook) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Set values for the recipient settings associated with a shared notebook.  Having
	// update rights to the shared notebook record itself has no effect on this call;
	// only the recipient of the shared notebook can can the recipient settings.
	//
	// If you do <i>not</i> wish to, or cannot, change one of the reminderNotifyEmail or
	// reminderNotifyInApp fields, you must leave that field unset in recipientSettings.
	// This method will skip that field for updates and leave the existing state as
	// it is.
	//
	// @return The update sequence number of the account to which the shared notebook
	//   belongs, which is the account from which we are sharing a notebook.
	//
	// @throws EDAMNotFoundException "sharedNotebookId" - Thrown if the service does not
	//   have a shared notebook record for the sharedNotebookId on the given shard.  If you
	//   receive this exception, it is probable that the shared notebook record has
	//   been revoked or expired, or that you accessed the wrong shard.
	//
	// @throws EDAMUserException <ul>
	//   <li>PEMISSION_DENIED "authenticationToken" - If you do not have permission to set
	//       the recipient settings for the shared notebook.  Only the recipient has
	//       permission to do this.
	//   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting whether
	//       or not you want to receive reminder e-mail notifications is possible on
	//       a business notebook in the business to which the user belongs.  All
	//       others can safely unset the reminderNotifyEmail field from the
	//       recipientSettings parameter.
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - SharedNotebookId
	//  - RecipientSettings
	SetSharedNotebookRecipientSettings(ctx context.Context, authenticationToken string, sharedNotebookId int64, recipientSettings *Types.SharedNotebookRecipientSettings) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Send a reminder message to some or all of the email addresses that a notebook has been
	// shared with. The message includes the current link to view the notebook.
	// @param authenticationToken
	//   The auth token of the user with permissions to share the notebook
	// @param notebookGuid
	//   The guid of the shared notebook
	// @param messageText
	//  User provided text to include in the email
	// @param recipients
	//  The email addresses of the recipients. If this list is empty then all of the
	//  users that the notebook has been shared with are emailed.
	//  If an email address doesn't correspond to share invite members then that address
	//  is ignored.
	// @return
	//  The number of messages sent
	// @throws EDAMUserException <ul>
	//   <li> LIMIT_REACHED "(recipients)" -
	//     The email can't be sent because this would exceed the user's daily
	//     email limit.
	//   </li>
	//   <li> PERMISSION_DENIED "Notebook.guid" - The user doesn't have permission to
	//     send a message for the specified notebook.
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Notebook.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - NotebookGuid
	//  - MessageText
	//  - Recipients
	SendMessageToSharedNotebookMembers(ctx context.Context, authenticationToken string, notebookGuid Types.Guid, messageText string, recipients []string) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Lists the collection of shared notebooks for all notebooks in the
	// users account.
	//
	// @return
	//  The list of all SharedNotebooks for the user
	//
	// Parameters:
	//  - AuthenticationToken
	ListSharedNotebooks(ctx context.Context, authenticationToken string) (r []*Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Expunges the SharedNotebooks in the user's account using the
	// SharedNotebook.id as the identifier.
	// <p/>
	// NOTE: This function is generally not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param
	//   sharedNotebookIds - a list of ShardNotebook.id longs identifying the
	//       objects to delete permanently.
	//
	// @return
	//   The account's update sequence number.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - SharedNotebookIds
	ExpungeSharedNotebooks(ctx context.Context, authenticationToken string, sharedNotebookIds []int64) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Asks the service to make a linked notebook with the provided name, username
	// of the owner and identifiers provided. A linked notebook can be either a
	// link to a public notebook or to a private shared notebook.
	//
	// @param linkedNotebook
	//   The desired fields for the linked notebook must be provided on this
	//   object.  The name of the linked notebook must be set. Either a username
	//   uri or a shard id and share key must be provided otherwise a
	//   EDAMUserException is thrown.
	//
	// @return
	//   The newly created LinkedNotebook.  The server-side id will be
	//   saved in this object's 'id' field.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
	//   </li>
	//   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
	//   </li>
	//   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
	//     if public notebook set but bad uri
	//   </li>
	//   <li> BAD_DATA_FORMAT "LinkedNotebook.shareKey" -
	//     if private notebook set but bad shareKey
	//   </li>
	//   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
	//     if private notebook but shard id not provided
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - LinkedNotebook
	CreateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (r *Types.LinkedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// @param linkedNotebook
	//   Updates the name of a linked notebook.
	//
	// @return
	//   The Update Sequence Number for this change within the account.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - LinkedNotebook
	UpdateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Returns a list of linked notebooks
	//
	// Parameters:
	//  - AuthenticationToken
	ListLinkedNotebooks(ctx context.Context, authenticationToken string) (r []*Types.LinkedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Permanently expunges the linked notebook from the account.
	// <p/>
	// NOTE: This function is generally not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param guid
	//   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
	//   from the account.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	ExpungeLinkedNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Asks the service to produce an authentication token that can be used to
	// access the contents of a shared notebook from someone else's account.
	// This authenticationToken can be used with the various other NoteStore
	// calls to find and retrieve notes, and if the permissions in the shared
	// notebook are sufficient, to make changes to the contents of the notebook.
	//
	// @param shareKey
	//   The 'shareKey' identifier from the SharedNotebook that was granted to
	//   some recipient.  This string internally encodes the notebook identifier
	//   and a security signature.
	//
	// @param authenticationToken
	//   If a non-empty string is provided, this is the full user-based
	//   authentication token that identifies the user who is currently logged in
	//   and trying to access the shared notebook.  This may be required if the
	//   notebook was created with 'requireLogin'.
	//   If this string is empty, the service will attempt to authenticate to the
	//   shared notebook without any logged in user.
	//
	// @throws EDAMSystemException <ul>
	//   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string
	//   </li>
	//   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "SharedNotebook.id" - the shared notebook no longer exists
	//   </li>
	// </ul>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
	//          no valid authentication token was provided.
	//   </li>
	//   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
	//          and another username has already been bound to this notebook.
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - ShareKey
	//  - AuthenticationToken
	AuthenticateToSharedNotebook(ctx context.Context, shareKey string, authenticationToken string) (r *UserStore.AuthenticationResult, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// This function is used to retrieve extended information about a shared
	// notebook by a guest who has already authenticated to access that notebook.
	// This requires an 'authenticationToken' parameter which should be the
	// resut of a call to authenticateToSharedNotebook(...).
	// I.e. this is the token that gives access to the particular shared notebook
	// in someone else's account -- it's not the authenticationToken for the
	// owner of the notebook itself.
	//
	// @param authenticationToken
	//   Should be the authentication token retrieved from the reply of
	//   authenticateToSharedNotebook(ctx), proving access to a particular shared
	//   notebook.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "authenticationToken" -
	//          authentication token doesn't correspond to a valid shared notebook
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "SharedNotebook.id" - the shared notebook no longer exists
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	GetSharedNotebookByAuth(ctx context.Context, authenticationToken string) (r *Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Attempts to send a single note to one or more email recipients.
	// <p/>
	// NOTE: This function is generally not available to third party applications.
	// Calls will result in an EDAMUserException with the error code
	// PERMISSION_DENIED.
	//
	// @param authenticationToken
	//    The note will be sent as the user logged in via this token, using that
	//    user's registered email address.  If the authenticated user doesn't
	//    have permission to read that note, the emailing will fail.
	//
	// @param parameters
	//    The note must be specified either by GUID (in which case it will be
	//    sent using the existing data in the service), or else the full Note
	//    must be passed to this call.  This also specifies the additional
	//    email fields that will be used in the email.
	//
	// @throws EDAMUserException <ul>
	//   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
	//     The email can't be sent because this would exceed the user's daily
	//     email limit.
	//   </li>
	//   <li> BAD_DATA_FORMAT "(email address)" -
	//     email address malformed
	//   </li>
	//   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
	//     if there are no To: or Cc: addresses provided.
	//   </li>
	//   <li> DATA_REQUIRED "Note.title" -
	//     if the caller provides a Note parameter with no title
	//   </li>
	//   <li> DATA_REQUIRED "Note.content" -
	//     if the caller provides a Note parameter with no content
	//   </li>
	//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
	//   </li>
	//   <li> DATA_REQUIRED "NoteEmailParameters.note" -
	//     if no guid or note provided
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Parameters
	EmailNote(ctx context.Context, authenticationToken string, parameters *NoteEmailParameters) (userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// If this note is not already shared (via its own direct URL), then this
	// will start sharing that note.
	// This will return the secret "Note Key" for this note that
	// can currently be used in conjunction with the Note's GUID to gain direct
	// read-only access to the Note.
	// If the note is already shared, then this won't make any changes to the
	// note, and the existing "Note Key" will be returned.  The only way to change
	// the Note Key for an existing note is to stopSharingNote first, and then
	// call this function.
	//
	// @param guid
	//   The GUID of the note to be shared.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	ShareNote(ctx context.Context, authenticationToken string, guid Types.Guid) (r string, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// If this note is not already shared then this will stop sharing that note
	// and invalidate its "Note Key", so any existing URLs to access that Note
	// will stop working.
	// If the Note is not shared, then this function will do nothing.
	//
	// @param guid
	//   The GUID of the note to be un-shared.
	//
	// @throws EDAMUserException <ul>
	//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
	//   </li>
	//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "Note.guid" - not found, by GUID
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Guid
	StopSharingNote(ctx context.Context, authenticationToken string, guid Types.Guid) (userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Asks the service to produce an authentication token that can be used to
	// access the contents of a single Note which was individually shared
	// from someone's account.
	// This authenticationToken can be used with the various other NoteStore
	// calls to find and retrieve the Note and its directly-referenced children.
	//
	// @param guid
	//   The GUID identifying this Note on this shard.
	//
	// @param noteKey
	//   The 'noteKey' identifier from the Note that was originally created via
	//   a call to shareNote() and then given to a recipient to access.
	//
	// @param authenticationToken
	//   An optional authenticationToken that identifies the user accessing the
	//   shared note. This parameter may be required to access some shared notes.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
	//     shared, or the noteKey doesn't match the current key for this note
	//   </li>
	//   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
	//     required to access this Note, but either no authentication token or a
	//     "non-owner" authentication token was provided.
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li> "guid" - the note with that GUID is not found
	//   </li>
	// </ul>
	//
	// @throws EDAMSystemException <ul>
	//   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
	//     all requesters).
	//   </li>
	//   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
	//     for the requester because of an IP-based country lookup.
	//   </ul>
	// </ul>
	//
	// Parameters:
	//  - Guid
	//  - NoteKey
	//  - AuthenticationToken
	AuthenticateToSharedNote(ctx context.Context, guid string, noteKey string, authenticationToken string) (r *UserStore.AuthenticationResult, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error)
	// Identify related entities on the service, such as notes,
	// notebooks, and tags related to notes or content.
	//
	// @param query
	//   The information about which we are finding related entities.
	//
	// @param resultSpec
	//   Allows the client to indicate the type and quantity of
	//   information to be returned, allowing a saving of time and
	//   bandwidth.
	//
	// @return
	//   The result of the query, with information considered
	//   to likely be relevantly related to the information
	//   described by the query.
	//
	// @throws EDAMUserException <ul>
	//   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
	//     a zero-length plain text value.
	//   </li>
	//   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
	//     invalid Note GUID, that is, one that does not match the constraints
	//     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
	//   </li>
	//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
	//   </li>
	//   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
	//     the note identified by RelatedQuery.noteGuid.
	//   </li>
	//   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
	//     in the result spec.
	//   </li>
	// </ul>
	//
	// @throws EDAMNotFoundException <ul>
	//   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
	//     found, if that field has been set in the query.
	//   </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - Query
	//  - ResultSpec
	FindRelated(ctx context.Context, authenticationToken string, query *RelatedQuery, resultSpec *RelatedResultSpec) (r *RelatedResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error)
}

type NoteStoreClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewNoteStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *NoteStoreClient {
	return &NoteStoreClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewNoteStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *NoteStoreClient {
	return &NoteStoreClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Asks the NoteStore to provide information about the status of the user
// account corresponding to the provided authentication token.
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) GetSyncState(ctx context.Context, authenticationToken string) (r *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetSyncState(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvGetSyncState(ctx)
}

func (p *NoteStoreClient) sendGetSyncState(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getSyncState", thrift.CALL, p.SeqId)
	args29 := NewGetSyncStateArgs()
	args29.AuthenticationToken = authenticationToken
	err = args29.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetSyncState(ctx context.Context) (value *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error31 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error32 error
		err = error31.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error32
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result30 := NewGetSyncStateResult()
	err = result30.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result30.Success
	if result30.UserException != nil {
		userException = result30.UserException
	}
	if result30.SystemException != nil {
		systemException = result30.SystemException
	}
	return
}

// Asks the NoteStore to provide information about the status of the user
// account corresponding to the provided authentication token.
// This version of 'getSyncState' allows the client to upload coarse-
// grained usage metrics to the service.
//
// @param clientMetrics  see the documentation of the ClientUsageMetrics
//   structure for an explanation of the fields that clients can pass to
//   the service.
//
// Parameters:
//  - AuthenticationToken
//  - ClientMetrics
func (p *NoteStoreClient) GetSyncStateWithMetrics(ctx context.Context, authenticationToken string, clientMetrics *ClientUsageMetrics) (r *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetSyncStateWithMetrics(ctx, authenticationToken, clientMetrics); err != nil {
		return
	}
	return p.recvGetSyncStateWithMetrics(ctx)
}

func (p *NoteStoreClient) sendGetSyncStateWithMetrics(ctx context.Context, authenticationToken string, clientMetrics *ClientUsageMetrics) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getSyncStateWithMetrics", thrift.CALL, p.SeqId)
	args33 := NewGetSyncStateWithMetricsArgs()
	args33.AuthenticationToken = authenticationToken
	args33.ClientMetrics = clientMetrics
	err = args33.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetSyncStateWithMetrics(ctx context.Context) (value *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		err = error35.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result34 := NewGetSyncStateWithMetricsResult()
	err = result34.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result34.Success
	if result34.UserException != nil {
		userException = result34.UserException
	}
	if result34.SystemException != nil {
		systemException = result34.SystemException
	}
	return
}

// DEPRECATED - use getFilteredSyncChunk.
//
// Parameters:
//  - AuthenticationToken
//  - AfterUSN
//  - MaxEntries
//  - FullSyncOnly
func (p *NoteStoreClient) GetSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, fullSyncOnly bool) (r *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetSyncChunk(ctx, authenticationToken, afterUSN, maxEntries, fullSyncOnly); err != nil {
		return
	}
	return p.recvGetSyncChunk(ctx)
}

func (p *NoteStoreClient) sendGetSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, fullSyncOnly bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getSyncChunk", thrift.CALL, p.SeqId)
	args37 := NewGetSyncChunkArgs()
	args37.AuthenticationToken = authenticationToken
	args37.AfterUSN = afterUSN
	args37.MaxEntries = maxEntries
	args37.FullSyncOnly = fullSyncOnly
	err = args37.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetSyncChunk(ctx context.Context) (value *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		err = error39.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result38 := NewGetSyncChunkResult()
	err = result38.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result38.Success
	if result38.UserException != nil {
		userException = result38.UserException
	}
	if result38.SystemException != nil {
		systemException = result38.SystemException
	}
	return
}

// Asks the NoteStore to provide the state of the account in order of
// last modification.  This request retrieves one block of the server's
// state so that a client can make several small requests against a large
// account rather than getting the entire state in one big message.
// This call gives fine-grained control of the data that will
// be received by a client by omitting data elements that a client doesn't
// need. This may reduce network traffic and sync times.
//
// @param afterUSN
//   The client can pass this value to ask only for objects that
//   have been updated after a certain point.  This allows the client to
//   receive updates after its last checkpoint rather than doing a full
//   synchronization on every pass.  The default value of "0" indicates
//   that the client wants to get objects from the start of the account.
//
// @param maxEntries
//   The maximum number of modified objects that should be
//   returned in the result SyncChunk.  This can be used to limit the size
//   of each individual message to be friendly for network transfer.
//
// @param filter
//   The caller must set some of the flags in this structure to specify which
//   data types should be returned during the synchronization.  See
//   the SyncChunkFilter structure for information on each flag.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "afterUSN" - if negative
//   </li>
//   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - AfterUSN
//  - MaxEntries
//  - Filter
func (p *NoteStoreClient) GetFilteredSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, filter *SyncChunkFilter) (r *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetFilteredSyncChunk(ctx, authenticationToken, afterUSN, maxEntries, filter); err != nil {
		return
	}
	return p.recvGetFilteredSyncChunk(ctx)
}

func (p *NoteStoreClient) sendGetFilteredSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, filter *SyncChunkFilter) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getFilteredSyncChunk", thrift.CALL, p.SeqId)
	args41 := NewGetFilteredSyncChunkArgs()
	args41.AuthenticationToken = authenticationToken
	args41.AfterUSN = afterUSN
	args41.MaxEntries = maxEntries
	args41.Filter = filter
	err = args41.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetFilteredSyncChunk(ctx context.Context) (value *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		err = error43.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result42 := NewGetFilteredSyncChunkResult()
	err = result42.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result42.Success
	if result42.UserException != nil {
		userException = result42.UserException
	}
	if result42.SystemException != nil {
		systemException = result42.SystemException
	}
	return
}

// Asks the NoteStore to provide information about the status of a linked
// notebook that has been shared with the caller, or that is public to the
// world.
// This will return a result that is similar to getSyncState, but may omit
// SyncState.uploaded if the caller doesn't have permission to write to
// the linked notebook.
//
// This function must be called on the shard that owns the referenced
// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
// same as LinkedNotebook.shardId.)
//
// @param authenticationToken
//   This should be an authenticationToken for the guest who has received
//   the invitation to the share.  (I.e. this should not be the result of
//   NoteStore.authenticateToSharedNotebook)
//
// @param linkedNotebook
//   This structure should contain identifying information and permissions
//   to access the notebook in question.
//
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
func (p *NoteStoreClient) GetLinkedNotebookSyncState(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (r *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetLinkedNotebookSyncState(ctx, authenticationToken, linkedNotebook); err != nil {
		return
	}
	return p.recvGetLinkedNotebookSyncState(ctx)
}

func (p *NoteStoreClient) sendGetLinkedNotebookSyncState(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncState", thrift.CALL, p.SeqId)
	args45 := NewGetLinkedNotebookSyncStateArgs()
	args45.AuthenticationToken = authenticationToken
	args45.LinkedNotebook = linkedNotebook
	err = args45.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetLinkedNotebookSyncState(ctx context.Context) (value *SyncState, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		err = error47.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result46 := NewGetLinkedNotebookSyncStateResult()
	err = result46.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result46.Success
	if result46.UserException != nil {
		userException = result46.UserException
	}
	if result46.SystemException != nil {
		systemException = result46.SystemException
	}
	if result46.NotFoundException != nil {
		notFoundException = result46.NotFoundException
	}
	return
}

// Asks the NoteStore to provide information about the contents of a linked
// notebook that has been shared with the caller, or that is public to the
// world.
// This will return a result that is similar to getSyncChunk, but will only
// contain entries that are visible to the caller.  I.e. only that particular
// Notebook will be visible, along with its Notes, and Tags on those Notes.
//
// This function must be called on the shard that owns the referenced
// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
// same as LinkedNotebook.shardId.)
//
// @param authenticationToken
//   This should be an authenticationToken for the guest who has received
//   the invitation to the share.  (I.e. this should not be the result of
//   NoteStore.authenticateToSharedNotebook)
//
// @param linkedNotebook
//   This structure should contain identifying information and permissions
//   to access the notebook in question.  This must contain the valid fields
//   for either a shared notebook (e.g. shareKey)
//   or a public notebook (e.g. username, uri)
//
// @param afterUSN
//   The client can pass this value to ask only for objects that
//   have been updated after a certain point.  This allows the client to
//   receive updates after its last checkpoint rather than doing a full
//   synchronization on every pass.  The default value of "0" indicates
//   that the client wants to get objects from the start of the account.
//
// @param maxEntries
//   The maximum number of modified objects that should be
//   returned in the result SyncChunk.  This can be used to limit the size
//   of each individual message to be friendly for network transfer.
//   Applications should not request more than 256 objects at a time,
//   and must handle the case where the service returns less than the
//   requested number of objects in a given request even though more
//   objects are available on the service.
//
// @param fullSyncOnly
//   If true, then the client only wants initial data for a full sync.
//   In this case, the service will not return any expunged objects,
//   and will not return any Resources, since these are also provided
//   in their corresponding Notes.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "afterUSN" - if negative
//   </li>
//   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "LinkedNotebook" - if the provided information doesn't match any
//     valid notebook
//   </li>
//   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
//     valid notebook
//   </li>
//   <li> "SharedNotebook.id" - if the provided information indicates a
//      shared notebook that no longer exists
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
//  - AfterUSN
//  - MaxEntries
//  - FullSyncOnly
func (p *NoteStoreClient) GetLinkedNotebookSyncChunk(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook, afterUSN int32, maxEntries int32, fullSyncOnly bool) (r *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetLinkedNotebookSyncChunk(ctx, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly); err != nil {
		return
	}
	return p.recvGetLinkedNotebookSyncChunk(ctx)
}

func (p *NoteStoreClient) sendGetLinkedNotebookSyncChunk(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook, afterUSN int32, maxEntries int32, fullSyncOnly bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncChunk", thrift.CALL, p.SeqId)
	args49 := NewGetLinkedNotebookSyncChunkArgs()
	args49.AuthenticationToken = authenticationToken
	args49.LinkedNotebook = linkedNotebook
	args49.AfterUSN = afterUSN
	args49.MaxEntries = maxEntries
	args49.FullSyncOnly = fullSyncOnly
	err = args49.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetLinkedNotebookSyncChunk(ctx context.Context) (value *SyncChunk, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		err = error51.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error52
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result50 := NewGetLinkedNotebookSyncChunkResult()
	err = result50.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result50.Success
	if result50.UserException != nil {
		userException = result50.UserException
	}
	if result50.SystemException != nil {
		systemException = result50.SystemException
	}
	if result50.NotFoundException != nil {
		notFoundException = result50.NotFoundException
	}
	return
}

// Returns a list of all of the notebooks in the account.
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListNotebooks(ctx context.Context, authenticationToken string) (r []*Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendListNotebooks(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvListNotebooks(ctx)
}

func (p *NoteStoreClient) sendListNotebooks(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "listNotebooks", thrift.CALL, p.SeqId)
	args53 := NewListNotebooksArgs()
	args53.AuthenticationToken = authenticationToken
	err = args53.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvListNotebooks(ctx context.Context) (value []*Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		err = error55.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result54 := NewListNotebooksResult()
	err = result54.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result54.Success
	if result54.UserException != nil {
		userException = result54.UserException
	}
	if result54.SystemException != nil {
		systemException = result54.SystemException
	}
	return
}

// Returns the current state of the notebook with the provided GUID.
// The notebook may be active or deleted (but not expunged).
//
// @param guid
//   The GUID of the notebook to be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - tag not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNotebook(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetNotebook(ctx)
}

func (p *NoteStoreClient) sendGetNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNotebook", thrift.CALL, p.SeqId)
	args57 := NewGetNotebookArgs()
	args57.AuthenticationToken = authenticationToken
	args57.Guid = guid
	err = args57.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNotebook(ctx context.Context) (value *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		err = error59.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result58 := NewGetNotebookResult()
	err = result58.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result58.Success
	if result58.UserException != nil {
		userException = result58.UserException
	}
	if result58.SystemException != nil {
		systemException = result58.SystemException
	}
	if result58.NotFoundException != nil {
		notFoundException = result58.NotFoundException
	}
	return
}

// Returns the notebook that should be used to store new notes in the
// user's account when no other notebooks are specified.
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) GetDefaultNotebook(ctx context.Context, authenticationToken string) (r *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetDefaultNotebook(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvGetDefaultNotebook(ctx)
}

func (p *NoteStoreClient) sendGetDefaultNotebook(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getDefaultNotebook", thrift.CALL, p.SeqId)
	args61 := NewGetDefaultNotebookArgs()
	args61.AuthenticationToken = authenticationToken
	err = args61.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetDefaultNotebook(ctx context.Context) (value *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		err = error63.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result62 := NewGetDefaultNotebookResult()
	err = result62.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result62.Success
	if result62.UserException != nil {
		userException = result62.UserException
	}
	if result62.SystemException != nil {
		systemException = result62.SystemException
	}
	return
}

// Asks the service to make a notebook with the provided name.
//
// @param notebook
//   The desired fields for the notebook must be provided on this
//   object.  The name of the notebook must be set, and either the 'active'
//   or 'defaultNotebook' fields may be set by the client at creation.
//   If a notebook exists in the account with the same name (via
//   case-insensitive compare), this will throw an EDAMUserException.
//
// @return
//   The newly created Notebook.  The server-side GUID will be
//   saved in this object's 'guid' field.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
//   </li>
//   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
//   </li>
//   <li> DATA_CONFLICT "Notebook.name" - name already in use
//   </li>
//   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
//   </li>
//   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
//   </li>
//   <li> LIMIT_REACHED "Notebook" - at max number of notebooks
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Notebook
func (p *NoteStoreClient) CreateNotebook(ctx context.Context, authenticationToken string, notebook *Types.Notebook) (r *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendCreateNotebook(ctx, authenticationToken, notebook); err != nil {
		return
	}
	return p.recvCreateNotebook(ctx)
}

func (p *NoteStoreClient) sendCreateNotebook(ctx context.Context, authenticationToken string, notebook *Types.Notebook) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "createNotebook", thrift.CALL, p.SeqId)
	args65 := NewCreateNotebookArgs()
	args65.AuthenticationToken = authenticationToken
	args65.Notebook = notebook
	err = args65.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvCreateNotebook(ctx context.Context) (value *Types.Notebook, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		err = error67.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error68
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result66 := NewCreateNotebookResult()
	err = result66.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result66.Success
	if result66.UserException != nil {
		userException = result66.UserException
	}
	if result66.SystemException != nil {
		systemException = result66.SystemException
	}
	return
}

// Submits notebook changes to the service.  The provided data must include
// the notebook's guid field for identification.
//
// @param notebook
//   The notebook object containing the requested changes.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
//   </li>
//   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
//   </li>
//   <li> DATA_CONFLICT "Notebook.name" - name already in use
//   </li>
//   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
//   </li>
//   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Notebook
func (p *NoteStoreClient) UpdateNotebook(ctx context.Context, authenticationToken string, notebook *Types.Notebook) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUpdateNotebook(ctx, authenticationToken, notebook); err != nil {
		return
	}
	return p.recvUpdateNotebook(ctx)
}

func (p *NoteStoreClient) sendUpdateNotebook(ctx context.Context, authenticationToken string, notebook *Types.Notebook) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "updateNotebook", thrift.CALL, p.SeqId)
	args69 := NewUpdateNotebookArgs()
	args69.AuthenticationToken = authenticationToken
	args69.Notebook = notebook
	err = args69.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUpdateNotebook(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		err = error71.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error72
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result70 := NewUpdateNotebookResult()
	err = result70.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result70.Success
	if result70.UserException != nil {
		userException = result70.UserException
	}
	if result70.SystemException != nil {
		systemException = result70.SystemException
	}
	if result70.NotFoundException != nil {
		notFoundException = result70.NotFoundException
	}
	return
}

// Permanently removes the notebook from the user's account.
// After this action, the notebook is no longer available for undeletion, etc.
// If the notebook contains any Notes, they will be moved to the current
// default notebook and moved into the trash (i.e. Note.active=false).
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param guid
//   The GUID of the notebook to delete.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
//   </li>
//   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
//   </li>
//   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) ExpungeNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendExpungeNotebook(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvExpungeNotebook(ctx)
}

func (p *NoteStoreClient) sendExpungeNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeNotebook", thrift.CALL, p.SeqId)
	args73 := NewExpungeNotebookArgs()
	args73.AuthenticationToken = authenticationToken
	args73.Guid = guid
	err = args73.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeNotebook(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		err = error75.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error76
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result74 := NewExpungeNotebookResult()
	err = result74.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result74.Success
	if result74.UserException != nil {
		userException = result74.UserException
	}
	if result74.SystemException != nil {
		systemException = result74.SystemException
	}
	if result74.NotFoundException != nil {
		notFoundException = result74.NotFoundException
	}
	return
}

// Returns a list of the tags in the account.  Evernote does not support
// the undeletion of tags, so this will only include active tags.
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListTags(ctx context.Context, authenticationToken string) (r []*Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendListTags(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvListTags(ctx)
}

func (p *NoteStoreClient) sendListTags(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "listTags", thrift.CALL, p.SeqId)
	args77 := NewListTagsArgs()
	args77.AuthenticationToken = authenticationToken
	err = args77.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvListTags(ctx context.Context) (value []*Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error79 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error80 error
		err = error79.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error80
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result78 := NewListTagsResult()
	err = result78.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result78.Success
	if result78.UserException != nil {
		userException = result78.UserException
	}
	if result78.SystemException != nil {
		systemException = result78.SystemException
	}
	return
}

// Returns a list of the tags that are applied to at least one note within
// the provided notebook.  If the notebook is public, the authenticationToken
// may be ignored.
//
// @param notebookGuid
//    the GUID of the notebook to use to find tags
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - notebook not found by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - NotebookGuid
func (p *NoteStoreClient) ListTagsByNotebook(ctx context.Context, authenticationToken string, notebookGuid Types.Guid) (r []*Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendListTagsByNotebook(ctx, authenticationToken, notebookGuid); err != nil {
		return
	}
	return p.recvListTagsByNotebook(ctx)
}

func (p *NoteStoreClient) sendListTagsByNotebook(ctx context.Context, authenticationToken string, notebookGuid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "listTagsByNotebook", thrift.CALL, p.SeqId)
	args81 := NewListTagsByNotebookArgs()
	args81.AuthenticationToken = authenticationToken
	args81.NotebookGuid = notebookGuid
	err = args81.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvListTagsByNotebook(ctx context.Context) (value []*Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error83 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error84 error
		err = error83.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error84
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result82 := NewListTagsByNotebookResult()
	err = result82.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result82.Success
	if result82.UserException != nil {
		userException = result82.UserException
	}
	if result82.SystemException != nil {
		systemException = result82.SystemException
	}
	if result82.NotFoundException != nil {
		notFoundException = result82.NotFoundException
	}
	return
}

// Returns the current state of the Tag with the provided GUID.
//
// @param guid
//   The GUID of the tag to be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetTag(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetTag(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetTag(ctx)
}

func (p *NoteStoreClient) sendGetTag(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getTag", thrift.CALL, p.SeqId)
	args85 := NewGetTagArgs()
	args85.AuthenticationToken = authenticationToken
	args85.Guid = guid
	err = args85.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetTag(ctx context.Context) (value *Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error87 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error88 error
		err = error87.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error88
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result86 := NewGetTagResult()
	err = result86.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result86.Success
	if result86.UserException != nil {
		userException = result86.UserException
	}
	if result86.SystemException != nil {
		systemException = result86.SystemException
	}
	if result86.NotFoundException != nil {
		notFoundException = result86.NotFoundException
	}
	return
}

// Asks the service to make a tag with a set of information.
//
// @param tag
//   The desired list of fields for the tag are specified in this
//   object.  The caller must specify the tag name, and may provide
//   the parentGUID.
//
// @return
//   The newly created Tag.  The server-side GUID will be
//   saved in this object.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
//   </li>
//   <li> DATA_CONFLICT "Tag.name" - name already in use
//   </li>
//   <li> LIMIT_REACHED "Tag" - at max number of tags
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.parentGuid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Tag
func (p *NoteStoreClient) CreateTag(ctx context.Context, authenticationToken string, tag *Types.Tag) (r *Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendCreateTag(ctx, authenticationToken, tag); err != nil {
		return
	}
	return p.recvCreateTag(ctx)
}

func (p *NoteStoreClient) sendCreateTag(ctx context.Context, authenticationToken string, tag *Types.Tag) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "createTag", thrift.CALL, p.SeqId)
	args89 := NewCreateTagArgs()
	args89.AuthenticationToken = authenticationToken
	args89.Tag = tag
	err = args89.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvCreateTag(ctx context.Context) (value *Types.Tag, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error91 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error92 error
		err = error91.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error92
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result90 := NewCreateTagResult()
	err = result90.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result90.Success
	if result90.UserException != nil {
		userException = result90.UserException
	}
	if result90.SystemException != nil {
		systemException = result90.SystemException
	}
	if result90.NotFoundException != nil {
		notFoundException = result90.NotFoundException
	}
	return
}

// Submits tag changes to the service.  The provided data must include
// the tag's guid field for identification.  The service will apply
// updates to the following tag fields:  name, parentGuid
//
// @param tag
//   The tag object containing the requested changes.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
//   </li>
//   <li> DATA_CONFLICT "Tag.name" - name already in use
//   </li>
//   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
//   </li>
//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
//   <li> "Tag.parentGuid" - parent not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Tag
func (p *NoteStoreClient) UpdateTag(ctx context.Context, authenticationToken string, tag *Types.Tag) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUpdateTag(ctx, authenticationToken, tag); err != nil {
		return
	}
	return p.recvUpdateTag(ctx)
}

func (p *NoteStoreClient) sendUpdateTag(ctx context.Context, authenticationToken string, tag *Types.Tag) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "updateTag", thrift.CALL, p.SeqId)
	args93 := NewUpdateTagArgs()
	args93.AuthenticationToken = authenticationToken
	args93.Tag = tag
	err = args93.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUpdateTag(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error96 error
		err = error95.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error96
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result94 := NewUpdateTagResult()
	err = result94.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result94.Success
	if result94.UserException != nil {
		userException = result94.UserException
	}
	if result94.SystemException != nil {
		systemException = result94.SystemException
	}
	if result94.NotFoundException != nil {
		notFoundException = result94.NotFoundException
	}
	return
}

// Removes the provided tag from every note that is currently tagged with
// this tag.  If this operation is successful, the tag will still be in
// the account, but it will not be tagged on any notes.
//
// This function is not indended for use by full synchronizing clients, since
// it does not provide enough result information to the client to reconcile
// the local state without performing a follow-up sync from the service.  This
// is intended for "thin clients" that need to efficiently support this as
// a UI operation.
//
// @param guid
//   The GUID of the tag to remove from all notes.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) UntagAll(ctx context.Context, authenticationToken string, guid Types.Guid) (userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUntagAll(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvUntagAll(ctx)
}

func (p *NoteStoreClient) sendUntagAll(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "untagAll", thrift.CALL, p.SeqId)
	args97 := NewUntagAllArgs()
	args97.AuthenticationToken = authenticationToken
	args97.Guid = guid
	err = args97.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUntagAll(ctx context.Context) (userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error99 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error100 error
		err = error99.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error100
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result98 := NewUntagAllResult()
	err = result98.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	if result98.UserException != nil {
		userException = result98.UserException
	}
	if result98.SystemException != nil {
		systemException = result98.SystemException
	}
	if result98.NotFoundException != nil {
		notFoundException = result98.NotFoundException
	}
	return
}

// Permanently deletes the tag with the provided GUID, if present.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param guid
//   The GUID of the tag to delete.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) ExpungeTag(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendExpungeTag(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvExpungeTag(ctx)
}

func (p *NoteStoreClient) sendExpungeTag(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeTag", thrift.CALL, p.SeqId)
	args101 := NewExpungeTagArgs()
	args101.AuthenticationToken = authenticationToken
	args101.Guid = guid
	err = args101.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeTag(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error103 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error104 error
		err = error103.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error104
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result102 := NewExpungeTagResult()
	err = result102.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result102.Success
	if result102.UserException != nil {
		userException = result102.UserException
	}
	if result102.SystemException != nil {
		systemException = result102.SystemException
	}
	if result102.NotFoundException != nil {
		notFoundException = result102.NotFoundException
	}
	return
}

// Returns a list of the searches in the account.  Evernote does not support
// the undeletion of searches, so this will only include active searches.
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListSearches(ctx context.Context, authenticationToken string) (r []*Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendListSearches(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvListSearches(ctx)
}

func (p *NoteStoreClient) sendListSearches(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "listSearches", thrift.CALL, p.SeqId)
	args105 := NewListSearchesArgs()
	args105.AuthenticationToken = authenticationToken
	err = args105.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvListSearches(ctx context.Context) (value []*Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error107 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error108 error
		err = error107.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error108
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result106 := NewListSearchesResult()
	err = result106.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result106.Success
	if result106.UserException != nil {
		userException = result106.UserException
	}
	if result106.SystemException != nil {
		systemException = result106.SystemException
	}
	return
}

// Returns the current state of the search with the provided GUID.
//
// @param guid
//   The GUID of the search to be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
//   </li>
//
// @throws EDAMNotFoundException <ul>
//   <li> "SavedSearch.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetSearch(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetSearch(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetSearch(ctx)
}

func (p *NoteStoreClient) sendGetSearch(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getSearch", thrift.CALL, p.SeqId)
	args109 := NewGetSearchArgs()
	args109.AuthenticationToken = authenticationToken
	args109.Guid = guid
	err = args109.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetSearch(ctx context.Context) (value *Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error111 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error112 error
		err = error111.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error112
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result110 := NewGetSearchResult()
	err = result110.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result110.Success
	if result110.UserException != nil {
		userException = result110.UserException
	}
	if result110.SystemException != nil {
		systemException = result110.SystemException
	}
	if result110.NotFoundException != nil {
		notFoundException = result110.NotFoundException
	}
	return
}

// Asks the service to make a saved search with a set of information.
//
// @param search
//   The desired list of fields for the search are specified in this
//   object. The caller must specify the name and query for the
//   search, and may optionally specify a search scope.
//   The SavedSearch.format field is ignored by the service.
//
// @return
//   The newly created SavedSearch.  The server-side GUID will be
//   saved in this object.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
//   </li>
//   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
//   </li>
//   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Search
func (p *NoteStoreClient) CreateSearch(ctx context.Context, authenticationToken string, search *Types.SavedSearch) (r *Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendCreateSearch(ctx, authenticationToken, search); err != nil {
		return
	}
	return p.recvCreateSearch(ctx)
}

func (p *NoteStoreClient) sendCreateSearch(ctx context.Context, authenticationToken string, search *Types.SavedSearch) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "createSearch", thrift.CALL, p.SeqId)
	args113 := NewCreateSearchArgs()
	args113.AuthenticationToken = authenticationToken
	args113.Search = search
	err = args113.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvCreateSearch(ctx context.Context) (value *Types.SavedSearch, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error115 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error116 error
		err = error115.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error116
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result114 := NewCreateSearchResult()
	err = result114.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result114.Success
	if result114.UserException != nil {
		userException = result114.UserException
	}
	if result114.SystemException != nil {
		systemException = result114.SystemException
	}
	return
}

// Submits search changes to the service. The provided data must include
// the search's guid field for identification. The service will apply
// updates to the following search fields: name, query, and scope.
//
// @param search
//   The search object containing the requested changes.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
//   </li>
//   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
//   </li>
//   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "SavedSearch.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Search
func (p *NoteStoreClient) UpdateSearch(ctx context.Context, authenticationToken string, search *Types.SavedSearch) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUpdateSearch(ctx, authenticationToken, search); err != nil {
		return
	}
	return p.recvUpdateSearch(ctx)
}

func (p *NoteStoreClient) sendUpdateSearch(ctx context.Context, authenticationToken string, search *Types.SavedSearch) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "updateSearch", thrift.CALL, p.SeqId)
	args117 := NewUpdateSearchArgs()
	args117.AuthenticationToken = authenticationToken
	args117.Search = search
	err = args117.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUpdateSearch(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error119 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error120 error
		err = error119.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error120
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result118 := NewUpdateSearchResult()
	err = result118.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result118.Success
	if result118.UserException != nil {
		userException = result118.UserException
	}
	if result118.SystemException != nil {
		systemException = result118.SystemException
	}
	if result118.NotFoundException != nil {
		notFoundException = result118.NotFoundException
	}
	return
}

// Permanently deletes the saved search with the provided GUID, if present.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param guid
//   The GUID of the search to delete.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
//   </li>
//   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "SavedSearch.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) ExpungeSearch(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendExpungeSearch(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvExpungeSearch(ctx)
}

func (p *NoteStoreClient) sendExpungeSearch(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeSearch", thrift.CALL, p.SeqId)
	args121 := NewExpungeSearchArgs()
	args121.AuthenticationToken = authenticationToken
	args121.Guid = guid
	err = args121.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeSearch(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error123 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error124 error
		err = error123.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error124
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result122 := NewExpungeSearchResult()
	err = result122.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result122.Success
	if result122.UserException != nil {
		userException = result122.UserException
	}
	if result122.SystemException != nil {
		systemException = result122.SystemException
	}
	if result122.NotFoundException != nil {
		notFoundException = result122.NotFoundException
	}
	return
}

// DEPRECATED. Use findNotesMetadata.
//
// Parameters:
//  - AuthenticationToken
//  - Filter
//  - Offset
//  - MaxNotes
func (p *NoteStoreClient) FindNotes(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32) (r *NoteList, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendFindNotes(ctx, authenticationToken, filter, offset, maxNotes); err != nil {
		return
	}
	return p.recvFindNotes(ctx)
}

func (p *NoteStoreClient) sendFindNotes(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "findNotes", thrift.CALL, p.SeqId)
	args125 := NewFindNotesArgs()
	args125.AuthenticationToken = authenticationToken
	args125.Filter = filter
	args125.Offset = offset
	args125.MaxNotes = maxNotes
	err = args125.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvFindNotes(ctx context.Context) (value *NoteList, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error127 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error128 error
		err = error127.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error128
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result126 := NewFindNotesResult()
	err = result126.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result126.Success
	if result126.UserException != nil {
		userException = result126.UserException
	}
	if result126.SystemException != nil {
		systemException = result126.SystemException
	}
	if result126.NotFoundException != nil {
		notFoundException = result126.NotFoundException
	}
	return
}

// Finds the position of a note within a sorted subset of all of the user's
// notes. This may be useful for thin clients that are displaying a paginated
// listing of a large account, which need to know where a particular note
// sits in the list without retrieving all notes first.
//
// @param authenticationToken
//   Must be a valid token for the user's account unless the NoteFilter
//   'notebookGuid' is the GUID of a public notebook.
//
// @param filter
//   The list of criteria that will constrain the notes to be returned.
//
// @param guid
//   The GUID of the note to be retrieved.
//
// @return
//   If the note with the provided GUID is found within the matching note
//   list, this will return the offset of that note within that list (where
//   the first offset is 0).  If the note is not found within the set of
//   notes, this will return -1.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
//   </li>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Filter
//  - Guid
func (p *NoteStoreClient) FindNoteOffset(ctx context.Context, authenticationToken string, filter *NoteFilter, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendFindNoteOffset(ctx, authenticationToken, filter, guid); err != nil {
		return
	}
	return p.recvFindNoteOffset(ctx)
}

func (p *NoteStoreClient) sendFindNoteOffset(ctx context.Context, authenticationToken string, filter *NoteFilter, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "findNoteOffset", thrift.CALL, p.SeqId)
	args129 := NewFindNoteOffsetArgs()
	args129.AuthenticationToken = authenticationToken
	args129.Filter = filter
	args129.Guid = guid
	err = args129.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvFindNoteOffset(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error131 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error132 error
		err = error131.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error132
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result130 := NewFindNoteOffsetResult()
	err = result130.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result130.Success
	if result130.UserException != nil {
		userException = result130.UserException
	}
	if result130.SystemException != nil {
		systemException = result130.SystemException
	}
	if result130.NotFoundException != nil {
		notFoundException = result130.NotFoundException
	}
	return
}

// Used to find the high-level information about a set of the notes from a
// user's account based on various criteria specified via a NoteFilter object.
// <p/>
// Web applications that wish to periodically check for new content in a user's
// Evernote account should consider using webhooks instead of polling this API.
// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
// for more information.
//
// @param authenticationToken
//   Must be a valid token for the user's account unless the NoteFilter
//   'notebookGuid' is the GUID of a public notebook.
//
// @param filter
//   The list of criteria that will constrain the notes to be returned.
//
// @param offset
//   The numeric index of the first note to show within the sorted
//   results.  The numbering scheme starts with "0".  This can be used for
//   pagination.
//
// @param maxNotes
//   The mximum notes to return in this query.  The service will return a set
//   of notes that is no larger than this number, but may return fewer notes
//   if needed.  The NoteList.totalNotes field in the return value will
//   indicate whether there are more values available after the returned set.
//
// @param resultSpec
//   This specifies which information should be returned for each matching
//   Note. The fields on this structure can be used to eliminate data that
//   the client doesn't need, which will reduce the time and bandwidth
//   to receive and process the reply.
//
// @return
//   The list of notes that match the criteria.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Filter
//  - Offset
//  - MaxNotes
//  - ResultSpec
func (p *NoteStoreClient) FindNotesMetadata(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32, resultSpec *NotesMetadataResultSpec) (r *NotesMetadataList, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendFindNotesMetadata(ctx, authenticationToken, filter, offset, maxNotes, resultSpec); err != nil {
		return
	}
	return p.recvFindNotesMetadata(ctx)
}

func (p *NoteStoreClient) sendFindNotesMetadata(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32, resultSpec *NotesMetadataResultSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "findNotesMetadata", thrift.CALL, p.SeqId)
	args133 := NewFindNotesMetadataArgs()
	args133.AuthenticationToken = authenticationToken
	args133.Filter = filter
	args133.Offset = offset
	args133.MaxNotes = maxNotes
	args133.ResultSpec = resultSpec
	err = args133.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvFindNotesMetadata(ctx context.Context) (value *NotesMetadataList, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error135 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error136 error
		err = error135.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error136
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result134 := NewFindNotesMetadataResult()
	err = result134.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result134.Success
	if result134.UserException != nil {
		userException = result134.UserException
	}
	if result134.SystemException != nil {
		systemException = result134.SystemException
	}
	if result134.NotFoundException != nil {
		notFoundException = result134.NotFoundException
	}
	return
}

// This function is used to determine how many notes are found for each
// notebook and tag in the user's account, given a current set of filter
// parameters that determine the current selection.  This function will
// return a structure that gives the note count for each notebook and tag
// that has at least one note under the requested filter.  Any notebook or
// tag that has zero notes in the filtered set will not be listed in the
// reply to this function (so they can be assumed to be 0).
//
// @param authenticationToken
//   Must be a valid token for the user's account unless the NoteFilter
//   'notebookGuid' is the GUID of a public notebook.
//
// @param filter
//   The note selection filter that is currently being applied.  The note
//   counts are to be calculated with this filter applied to the total set
//   of notes in the user's account.
//
// @param withTrash
//   If true, then the NoteCollectionCounts.trashCount will be calculated
//   and supplied in the reply. Otherwise, the trash value will be omitted.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
//   </li>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Filter
//  - WithTrash
func (p *NoteStoreClient) FindNoteCounts(ctx context.Context, authenticationToken string, filter *NoteFilter, withTrash bool) (r *NoteCollectionCounts, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendFindNoteCounts(ctx, authenticationToken, filter, withTrash); err != nil {
		return
	}
	return p.recvFindNoteCounts(ctx)
}

func (p *NoteStoreClient) sendFindNoteCounts(ctx context.Context, authenticationToken string, filter *NoteFilter, withTrash bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "findNoteCounts", thrift.CALL, p.SeqId)
	args137 := NewFindNoteCountsArgs()
	args137.AuthenticationToken = authenticationToken
	args137.Filter = filter
	args137.WithTrash = withTrash
	err = args137.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvFindNoteCounts(ctx context.Context) (value *NoteCollectionCounts, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error139 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error140 error
		err = error139.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error140
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result138 := NewFindNoteCountsResult()
	err = result138.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result138.Success
	if result138.UserException != nil {
		userException = result138.UserException
	}
	if result138.SystemException != nil {
		systemException = result138.SystemException
	}
	if result138.NotFoundException != nil {
		notFoundException = result138.NotFoundException
	}
	return
}

// Returns the current state of the note in the service with the provided
// GUID.  The ENML contents of the note will only be provided if the
// 'withContent' parameter is true.  The service will include the meta-data
// for each resource in the note, but the binary contents of the resources
// and their recognition data will be omitted.
// If the Note is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).  The applicationData
// fields are returned as keysOnly.
//
// @param guid
//   The GUID of the note to be retrieved.
//
// @param withContent
//   If true, the note will include the ENML contents of its
//   'content' field.
//
// @param withResourcesData
//   If true, any Resource elements in this Note will include the binary
//   contents of their 'data' field's body.
//
// @param withResourcesRecognition
//   If true, any Resource elements will include the binary contents of the
//   'recognition' field's body if recognition data is present.
//
// @param withResourcesAlternateData
//   If true, any Resource elements in this Note will include the binary
//   contents of their 'alternateData' fields' body, if an alternate form
//   is present.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - WithContent
//  - WithResourcesData
//  - WithResourcesRecognition
//  - WithResourcesAlternateData
func (p *NoteStoreClient) GetNote(ctx context.Context, authenticationToken string, guid Types.Guid, withContent bool, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNote(ctx, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData); err != nil {
		return
	}
	return p.recvGetNote(ctx)
}

func (p *NoteStoreClient) sendGetNote(ctx context.Context, authenticationToken string, guid Types.Guid, withContent bool, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNote", thrift.CALL, p.SeqId)
	args141 := NewGetNoteArgs()
	args141.AuthenticationToken = authenticationToken
	args141.Guid = guid
	args141.WithContent = withContent
	args141.WithResourcesData = withResourcesData
	args141.WithResourcesRecognition = withResourcesRecognition
	args141.WithResourcesAlternateData = withResourcesAlternateData
	err = args141.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNote(ctx context.Context) (value *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error143 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error144 error
		err = error143.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error144
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result142 := NewGetNoteResult()
	err = result142.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result142.Success
	if result142.UserException != nil {
		userException = result142.UserException
	}
	if result142.SystemException != nil {
		systemException = result142.SystemException
	}
	if result142.NotFoundException != nil {
		notFoundException = result142.NotFoundException
	}
	return
}

// Get all of the application data for the note identified by GUID,
// with values returned within the LazyMap fullMap field.
// If there are no applicationData entries, then a LazyMap
// with an empty fullMap will be returned. If your application
// only needs to fetch its own applicationData entry, use
// getNoteApplicationDataEntry instead.
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetNoteApplicationData(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.LazyMap, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNoteApplicationData(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetNoteApplicationData(ctx)
}

func (p *NoteStoreClient) sendGetNoteApplicationData(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNoteApplicationData", thrift.CALL, p.SeqId)
	args145 := NewGetNoteApplicationDataArgs()
	args145.AuthenticationToken = authenticationToken
	args145.Guid = guid
	err = args145.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNoteApplicationData(ctx context.Context) (value *Types.LazyMap, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error147 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error148 error
		err = error147.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error148
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result146 := NewGetNoteApplicationDataResult()
	err = result146.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result146.Success
	if result146.UserException != nil {
		userException = result146.UserException
	}
	if result146.SystemException != nil {
		systemException = result146.SystemException
	}
	if result146.NotFoundException != nil {
		notFoundException = result146.NotFoundException
	}
	return
}

// Get the value of a single entry in the applicationData map
// for the note identified by GUID.
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - note not found, by GUID</li>
//   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - Key
func (p *NoteStoreClient) GetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNoteApplicationDataEntry(ctx, authenticationToken, guid, key); err != nil {
		return
	}
	return p.recvGetNoteApplicationDataEntry(ctx)
}

func (p *NoteStoreClient) sendGetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNoteApplicationDataEntry", thrift.CALL, p.SeqId)
	args149 := NewGetNoteApplicationDataEntryArgs()
	args149.AuthenticationToken = authenticationToken
	args149.Guid = guid
	args149.Key = key
	err = args149.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNoteApplicationDataEntry(ctx context.Context) (value string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error151 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error152 error
		err = error151.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error152
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result150 := NewGetNoteApplicationDataEntryResult()
	err = result150.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result150.Success
	if result150.UserException != nil {
		userException = result150.UserException
	}
	if result150.SystemException != nil {
		systemException = result150.SystemException
	}
	if result150.NotFoundException != nil {
		notFoundException = result150.NotFoundException
	}
	return
}

// Update, or create, an entry in the applicationData map for
// the note identified by guid.
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - Key
//  - Value
func (p *NoteStoreClient) SetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string, value string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendSetNoteApplicationDataEntry(ctx, authenticationToken, guid, key, value); err != nil {
		return
	}
	return p.recvSetNoteApplicationDataEntry(ctx)
}

func (p *NoteStoreClient) sendSetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string, value string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "setNoteApplicationDataEntry", thrift.CALL, p.SeqId)
	args153 := NewSetNoteApplicationDataEntryArgs()
	args153.AuthenticationToken = authenticationToken
	args153.Guid = guid
	args153.Key = key
	args153.Value = value
	err = args153.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvSetNoteApplicationDataEntry(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error155 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error156 error
		err = error155.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error156
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result154 := NewSetNoteApplicationDataEntryResult()
	err = result154.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result154.Success
	if result154.UserException != nil {
		userException = result154.UserException
	}
	if result154.SystemException != nil {
		systemException = result154.SystemException
	}
	if result154.NotFoundException != nil {
		notFoundException = result154.NotFoundException
	}
	return
}

// Remove an entry identified by 'key' from the applicationData map for
// the note identified by 'guid'. Silently ignores an unset of a
// non-existing key.
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - Key
func (p *NoteStoreClient) UnsetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUnsetNoteApplicationDataEntry(ctx, authenticationToken, guid, key); err != nil {
		return
	}
	return p.recvUnsetNoteApplicationDataEntry(ctx)
}

func (p *NoteStoreClient) sendUnsetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "unsetNoteApplicationDataEntry", thrift.CALL, p.SeqId)
	args157 := NewUnsetNoteApplicationDataEntryArgs()
	args157.AuthenticationToken = authenticationToken
	args157.Guid = guid
	args157.Key = key
	err = args157.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUnsetNoteApplicationDataEntry(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error159 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error160 error
		err = error159.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error160
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result158 := NewUnsetNoteApplicationDataEntryResult()
	err = result158.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result158.Success
	if result158.UserException != nil {
		userException = result158.UserException
	}
	if result158.SystemException != nil {
		systemException = result158.SystemException
	}
	if result158.NotFoundException != nil {
		notFoundException = result158.NotFoundException
	}
	return
}

// Returns XHTML contents of the note with the provided GUID.
// If the Note is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
//
// @param guid
//   The GUID of the note to be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetNoteContent(ctx context.Context, authenticationToken string, guid Types.Guid) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNoteContent(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetNoteContent(ctx)
}

func (p *NoteStoreClient) sendGetNoteContent(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNoteContent", thrift.CALL, p.SeqId)
	args161 := NewGetNoteContentArgs()
	args161.AuthenticationToken = authenticationToken
	args161.Guid = guid
	err = args161.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNoteContent(ctx context.Context) (value string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error163 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error164 error
		err = error163.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error164
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result162 := NewGetNoteContentResult()
	err = result162.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result162.Success
	if result162.UserException != nil {
		userException = result162.UserException
	}
	if result162.SystemException != nil {
		systemException = result162.SystemException
	}
	if result162.NotFoundException != nil {
		notFoundException = result162.NotFoundException
	}
	return
}

// Returns a block of the extracted plain text contents of the note with the
// provided GUID.  This text can be indexed for search purposes by a light
// client that doesn't have capabilities to extract all of the searchable
// text content from the note and its resources.
//
// If the Note is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
//
// @param guid
//   The GUID of the note to be retrieved.
//
// @param noteOnly
//   If true, this will only return the text extracted from the ENML contents
//   of the note itself.  If false, this will also include the extracted text
//   from any text-bearing resources (PDF, recognized images)
//
// @param tokenizeForIndexing
//   If true, this will break the text into cleanly separated and sanitized
//   tokens.  If false, this will return the more raw text extraction, with
//   its original punctuation, capitalization, spacing, etc.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - NoteOnly
//  - TokenizeForIndexing
func (p *NoteStoreClient) GetNoteSearchText(ctx context.Context, authenticationToken string, guid Types.Guid, noteOnly bool, tokenizeForIndexing bool) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNoteSearchText(ctx, authenticationToken, guid, noteOnly, tokenizeForIndexing); err != nil {
		return
	}
	return p.recvGetNoteSearchText(ctx)
}

func (p *NoteStoreClient) sendGetNoteSearchText(ctx context.Context, authenticationToken string, guid Types.Guid, noteOnly bool, tokenizeForIndexing bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNoteSearchText", thrift.CALL, p.SeqId)
	args165 := NewGetNoteSearchTextArgs()
	args165.AuthenticationToken = authenticationToken
	args165.Guid = guid
	args165.NoteOnly = noteOnly
	args165.TokenizeForIndexing = tokenizeForIndexing
	err = args165.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNoteSearchText(ctx context.Context) (value string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error167 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error168 error
		err = error167.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error168
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result166 := NewGetNoteSearchTextResult()
	err = result166.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result166.Success
	if result166.UserException != nil {
		userException = result166.UserException
	}
	if result166.SystemException != nil {
		systemException = result166.SystemException
	}
	if result166.NotFoundException != nil {
		notFoundException = result166.NotFoundException
	}
	return
}

// Returns a block of the extracted plain text contents of the resource with
// the provided GUID.  This text can be indexed for search purposes by a light
// client that doesn't have capability to extract all of the searchable
// text content from a resource.
//
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
//
// @param guid
//   The GUID of the resource to be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetResourceSearchText(ctx context.Context, authenticationToken string, guid Types.Guid) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceSearchText(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetResourceSearchText(ctx)
}

func (p *NoteStoreClient) sendGetResourceSearchText(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceSearchText", thrift.CALL, p.SeqId)
	args169 := NewGetResourceSearchTextArgs()
	args169.AuthenticationToken = authenticationToken
	args169.Guid = guid
	err = args169.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceSearchText(ctx context.Context) (value string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error171 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error172 error
		err = error171.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error172
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result170 := NewGetResourceSearchTextResult()
	err = result170.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result170.Success
	if result170.UserException != nil {
		userException = result170.UserException
	}
	if result170.SystemException != nil {
		systemException = result170.SystemException
	}
	if result170.NotFoundException != nil {
		notFoundException = result170.NotFoundException
	}
	return
}

// Returns a list of the names of the tags for the note with the provided
// guid.  This can be used with authentication to get the tags for a
// user's own note, or can be used without valid authentication to retrieve
// the names of the tags for a note in a public notebook.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetNoteTagNames(ctx context.Context, authenticationToken string, guid Types.Guid) (r []string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNoteTagNames(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetNoteTagNames(ctx)
}

func (p *NoteStoreClient) sendGetNoteTagNames(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNoteTagNames", thrift.CALL, p.SeqId)
	args173 := NewGetNoteTagNamesArgs()
	args173.AuthenticationToken = authenticationToken
	args173.Guid = guid
	err = args173.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNoteTagNames(ctx context.Context) (value []string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error175 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error176 error
		err = error175.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error176
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result174 := NewGetNoteTagNamesResult()
	err = result174.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result174.Success
	if result174.UserException != nil {
		userException = result174.UserException
	}
	if result174.SystemException != nil {
		systemException = result174.SystemException
	}
	if result174.NotFoundException != nil {
		notFoundException = result174.NotFoundException
	}
	return
}

// Asks the service to make a note with the provided set of information.
//
// @param note
//   A Note object containing the desired fields to be populated on
//   the service.
//
// @return
//   The newly created Note from the service.  The server-side
//   GUIDs for the Note and any Resources will be saved in this object.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
//   </li>
//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
//   </li>
//   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
//   </li>
//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
//   </li>
//   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
//   </li>
//   <li> DATA_REQUIRED "Resource.data" - resource data body missing
//   </li>
//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
//   </li>
//   <li> LIMIT_REACHED "Note" - at max number per account
//   </li>
//   <li> LIMIT_REACHED "Note.size" - total note size too large
//   </li>
//   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
//   </li>
//   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
//   </li>
//   <li> LIMIT_REACHED "Resource.data.size" - resource too large
//   </li>
//   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
//   </li>
//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
//   </li>
//   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
//   </li>
//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
//     of the specified tags had an invalid length or pattern
//   </li>
//   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
//     new tags would exceed the maximum number per account
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.notebookGuid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Note
func (p *NoteStoreClient) CreateNote(ctx context.Context, authenticationToken string, note *Types.Note) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendCreateNote(ctx, authenticationToken, note); err != nil {
		return
	}
	return p.recvCreateNote(ctx)
}

func (p *NoteStoreClient) sendCreateNote(ctx context.Context, authenticationToken string, note *Types.Note) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "createNote", thrift.CALL, p.SeqId)
	args177 := NewCreateNoteArgs()
	args177.AuthenticationToken = authenticationToken
	args177.Note = note
	err = args177.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvCreateNote(ctx context.Context) (value *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error179 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error180 error
		err = error179.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error180
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result178 := NewCreateNoteResult()
	err = result178.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result178.Success
	if result178.UserException != nil {
		userException = result178.UserException
	}
	if result178.SystemException != nil {
		systemException = result178.SystemException
	}
	if result178.NotFoundException != nil {
		notFoundException = result178.NotFoundException
	}
	return
}

// Submit a set of changes to a note to the service.  The provided data
// must include the note's guid field for identification. The note's
// title must also be set.
//
// @param note
//   A Note object containing the desired fields to be populated on
//   the service. With the exception of the note's title and guid, fields
//   that are not being changed do not need to be set. If the content is not
//   being modified, note.content should be left unset. If the list of
//   resources is not being modified, note.resources should be left unset.
//
// @return
//   The metadata (no contents) for the Note on the server after the update
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
//   </li>
//   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
//   </li>
//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
//   </li>
//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
//   </li>
//   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
//   </li>
//   <li> DATA_REQUIRED "Resource.data" - resource data body missing
//   </li>
//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
//   </li>
//   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
//   </li>
//   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
//   </li>
//   <li> LIMIT_REACHED "Note.size" - total note size too large
//   </li>
//   <li> LIMIT_REACHED "Resource.data.size" - resource too large
//   </li>
//   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
//   </li>
//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
//   </li>
//   <li> PERMISSION_DENIED "Note" - user doesn't own
//   </li>
//   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
//   </li>
//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
//     of the specified tags had an invalid length or pattern
//   </li>
//   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
//     new tags would exceed the maximum number per account
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - note not found, by GUID
//   </li>
//   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Note
func (p *NoteStoreClient) UpdateNote(ctx context.Context, authenticationToken string, note *Types.Note) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUpdateNote(ctx, authenticationToken, note); err != nil {
		return
	}
	return p.recvUpdateNote(ctx)
}

func (p *NoteStoreClient) sendUpdateNote(ctx context.Context, authenticationToken string, note *Types.Note) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "updateNote", thrift.CALL, p.SeqId)
	args181 := NewUpdateNoteArgs()
	args181.AuthenticationToken = authenticationToken
	args181.Note = note
	err = args181.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUpdateNote(ctx context.Context) (value *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error183 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error184 error
		err = error183.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error184
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result182 := NewUpdateNoteResult()
	err = result182.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result182.Success
	if result182.UserException != nil {
		userException = result182.UserException
	}
	if result182.SystemException != nil {
		systemException = result182.SystemException
	}
	if result182.NotFoundException != nil {
		notFoundException = result182.NotFoundException
	}
	return
}

// Moves the note into the trash. The note may still be undeleted, unless it
// is expunged.  This is equivalent to calling updateNote() after setting
// Note.active = false
//
// @param guid
//   The GUID of the note to delete.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
//          update the note.
//   </li>
// </ul>
//
// @throws EDAMUserException <ul>
//   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
//   </li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) DeleteNote(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendDeleteNote(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvDeleteNote(ctx)
}

func (p *NoteStoreClient) sendDeleteNote(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "deleteNote", thrift.CALL, p.SeqId)
	args185 := NewDeleteNoteArgs()
	args185.AuthenticationToken = authenticationToken
	args185.Guid = guid
	err = args185.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvDeleteNote(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error187 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error188 error
		err = error187.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error188
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result186 := NewDeleteNoteResult()
	err = result186.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result186.Success
	if result186.UserException != nil {
		userException = result186.UserException
	}
	if result186.SystemException != nil {
		systemException = result186.SystemException
	}
	if result186.NotFoundException != nil {
		notFoundException = result186.NotFoundException
	}
	return
}

// Permanently removes a Note, and all of its Resources,
// from the service.
// <p/>
// NOTE: This function is not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param guid
//   The GUID of the note to delete.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "Note" - user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) ExpungeNote(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendExpungeNote(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvExpungeNote(ctx)
}

func (p *NoteStoreClient) sendExpungeNote(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeNote", thrift.CALL, p.SeqId)
	args189 := NewExpungeNoteArgs()
	args189.AuthenticationToken = authenticationToken
	args189.Guid = guid
	err = args189.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeNote(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error191 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error192 error
		err = error191.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error192
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result190 := NewExpungeNoteResult()
	err = result190.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result190.Success
	if result190.UserException != nil {
		userException = result190.UserException
	}
	if result190.SystemException != nil {
		systemException = result190.SystemException
	}
	if result190.NotFoundException != nil {
		notFoundException = result190.NotFoundException
	}
	return
}

// Permanently removes a list of Notes, and all of their Resources, from
// the service.  This should be invoked with a small number of Note GUIDs
// (e.g. 100 or less) on each call.  To expunge a larger number of notes,
// call this method multiple times.  This should also be used to reduce the
// number of Notes in a notebook before calling expungeNotebook(ctx) or
// in the trash before calling expungeInactiveNotes(ctx), since these calls may
// be prohibitively slow if there are more than a few hundred notes.
// If an exception is thrown for any of the GUIDs, then none of the notes
// will be deleted.  I.e. this call can be treated as an atomic transaction.
// <p/>
// NOTE: This function is not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param noteGuids
//   The list of GUIDs for the Notes to remove.
//
// @return
//   The account's updateCount at the end of this operation
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "Note" - user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - NoteGuids
func (p *NoteStoreClient) ExpungeNotes(ctx context.Context, authenticationToken string, noteGuids []Types.Guid) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendExpungeNotes(ctx, authenticationToken, noteGuids); err != nil {
		return
	}
	return p.recvExpungeNotes(ctx)
}

func (p *NoteStoreClient) sendExpungeNotes(ctx context.Context, authenticationToken string, noteGuids []Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeNotes", thrift.CALL, p.SeqId)
	args193 := NewExpungeNotesArgs()
	args193.AuthenticationToken = authenticationToken
	args193.NoteGuids = noteGuids
	err = args193.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeNotes(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error195 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error196 error
		err = error195.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error196
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result194 := NewExpungeNotesResult()
	err = result194.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result194.Success
	if result194.UserException != nil {
		userException = result194.UserException
	}
	if result194.SystemException != nil {
		systemException = result194.SystemException
	}
	if result194.NotFoundException != nil {
		notFoundException = result194.NotFoundException
	}
	return
}

// Permanently removes all of the Notes that are currently marked as
// inactive.  This is equivalent to "emptying the trash", and these Notes
// will be gone permanently.
// <p/>
// This operation may be relatively slow if the account contains a large
// number of inactive Notes.
// <p/>
// NOTE: This function is not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @return
//    The number of notes that were expunged.
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ExpungeInactiveNotes(ctx context.Context, authenticationToken string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendExpungeInactiveNotes(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvExpungeInactiveNotes(ctx)
}

func (p *NoteStoreClient) sendExpungeInactiveNotes(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeInactiveNotes", thrift.CALL, p.SeqId)
	args197 := NewExpungeInactiveNotesArgs()
	args197.AuthenticationToken = authenticationToken
	err = args197.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeInactiveNotes(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error199 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error200 error
		err = error199.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error200
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result198 := NewExpungeInactiveNotesResult()
	err = result198.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result198.Success
	if result198.UserException != nil {
		userException = result198.UserException
	}
	if result198.SystemException != nil {
		systemException = result198.SystemException
	}
	return
}

// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
// the Notebook with the provided GUID 'toNotebookGuid'.
// The caller must be the owner of both the Note and the Notebook.
// This creates a new Note in the destination Notebook with new content and
// Resources that match all of the content and Resources from the original
// Note, but with new GUID identifiers.
// The original Note is not modified by this operation.
// The copied note is considered as an "upload" for the purpose of upload
// transfer limit calculation, so its size is added to the upload count for
// the owner.
//
// @param noteGuid
//   The GUID of the Note to copy.
//
// @param toNotebookGuid
//   The GUID of the Notebook that should receive the new Note.
//
// @return
//   The metadata for the new Note that was created.  This will include the
//   new GUID for this Note (and any copied Resources), but will not include
//   the content body or the binary bodies of any Resources.
//
// @throws EDAMUserException <ul>
//   <li> LIMIT_REACHED "Note" - at max number per account
//   </li>
//   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
//   </li>
//   <li> PERMISSION_DENIED "Note" - user doesn't own
//   </li>
//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
//  - ToNotebookGuid
func (p *NoteStoreClient) CopyNote(ctx context.Context, authenticationToken string, noteGuid Types.Guid, toNotebookGuid Types.Guid) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendCopyNote(ctx, authenticationToken, noteGuid, toNotebookGuid); err != nil {
		return
	}
	return p.recvCopyNote(ctx)
}

func (p *NoteStoreClient) sendCopyNote(ctx context.Context, authenticationToken string, noteGuid Types.Guid, toNotebookGuid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "copyNote", thrift.CALL, p.SeqId)
	args201 := NewCopyNoteArgs()
	args201.AuthenticationToken = authenticationToken
	args201.NoteGuid = noteGuid
	args201.ToNotebookGuid = toNotebookGuid
	err = args201.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvCopyNote(ctx context.Context) (value *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error203 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error204 error
		err = error203.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error204
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result202 := NewCopyNoteResult()
	err = result202.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result202.Success
	if result202.UserException != nil {
		userException = result202.UserException
	}
	if result202.SystemException != nil {
		systemException = result202.SystemException
	}
	if result202.NotFoundException != nil {
		notFoundException = result202.NotFoundException
	}
	return
}

// Returns a list of the prior versions of a particular note that are
// saved within the service.  These prior versions are stored to provide a
// recovery from unintentional removal of content from a note. The identifiers
// that are returned by this call can be used with getNoteVersion to retrieve
// the previous note.
// The identifiers will be listed from the most recent versions to the oldest.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
func (p *NoteStoreClient) ListNoteVersions(ctx context.Context, authenticationToken string, noteGuid Types.Guid) (r []*NoteVersionId, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendListNoteVersions(ctx, authenticationToken, noteGuid); err != nil {
		return
	}
	return p.recvListNoteVersions(ctx)
}

func (p *NoteStoreClient) sendListNoteVersions(ctx context.Context, authenticationToken string, noteGuid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "listNoteVersions", thrift.CALL, p.SeqId)
	args205 := NewListNoteVersionsArgs()
	args205.AuthenticationToken = authenticationToken
	args205.NoteGuid = noteGuid
	err = args205.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvListNoteVersions(ctx context.Context) (value []*NoteVersionId, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error207 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error208 error
		err = error207.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error208
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result206 := NewListNoteVersionsResult()
	err = result206.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result206.Success
	if result206.UserException != nil {
		userException = result206.UserException
	}
	if result206.SystemException != nil {
		systemException = result206.SystemException
	}
	if result206.NotFoundException != nil {
		notFoundException = result206.NotFoundException
	}
	return
}

// This can be used to retrieve a previous version of a Note after it has been
// updated within the service.  The caller must identify the note (via its
// guid) and the version (via the updateSequenceNumber of that version).
// to find a listing of the stored version USNs for a note, call
// listNoteVersions.
// This call is only available for notes in Premium accounts.  (I.e. access
// to past versions of Notes is a Premium-only feature.)
//
// @param noteGuid
//   The GUID of the note to be retrieved.
//
// @param updateSequenceNum
//   The USN of the version of the note that is being retrieved
//
// @param withResourcesData
//   If true, any Resource elements in this Note will include the binary
//   contents of their 'data' field's body.
//
// @param withResourcesRecognition
//   If true, any Resource elements will include the binary contents of the
//   'recognition' field's body if recognition data is present.
//
// @param withResourcesAlternateData
//   If true, any Resource elements in this Note will include the binary
//   contents of their 'alternateData' fields' body, if an alternate form
//   is present.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
//   <li> PERMISSION_DENIED "updateSequenceNum" -
//     The account isn't permitted to access previous versions of notes.
//     (i.e. this is a Free account.)
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
//   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
//      the corresponding USN.
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
//  - UpdateSequenceNum
//  - WithResourcesData
//  - WithResourcesRecognition
//  - WithResourcesAlternateData
func (p *NoteStoreClient) GetNoteVersion(ctx context.Context, authenticationToken string, noteGuid Types.Guid, updateSequenceNum int32, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (r *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetNoteVersion(ctx, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData); err != nil {
		return
	}
	return p.recvGetNoteVersion(ctx)
}

func (p *NoteStoreClient) sendGetNoteVersion(ctx context.Context, authenticationToken string, noteGuid Types.Guid, updateSequenceNum int32, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getNoteVersion", thrift.CALL, p.SeqId)
	args209 := NewGetNoteVersionArgs()
	args209.AuthenticationToken = authenticationToken
	args209.NoteGuid = noteGuid
	args209.UpdateSequenceNum = updateSequenceNum
	args209.WithResourcesData = withResourcesData
	args209.WithResourcesRecognition = withResourcesRecognition
	args209.WithResourcesAlternateData = withResourcesAlternateData
	err = args209.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetNoteVersion(ctx context.Context) (value *Types.Note, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error211 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error212 error
		err = error211.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error212
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result210 := NewGetNoteVersionResult()
	err = result210.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result210.Success
	if result210.UserException != nil {
		userException = result210.UserException
	}
	if result210.SystemException != nil {
		systemException = result210.SystemException
	}
	if result210.NotFoundException != nil {
		notFoundException = result210.NotFoundException
	}
	return
}

// Returns the current state of the resource in the service with the
// provided GUID.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).  Only the
// keys for the applicationData will be returned.
//
// @param guid
//   The GUID of the resource to be retrieved.
//
// @param withData
//   If true, the Resource will include the binary contents of the
//   'data' field's body.
//
// @param withRecognition
//   If true, the Resource will include the binary contents of the
//   'recognition' field's body if recognition data is present.
//
// @param withAttributes
//   If true, the Resource will include the attributes
//
// @param withAlternateData
//   If true, the Resource will include the binary contents of the
//   'alternateData' field's body, if an alternate form is present.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - WithData
//  - WithRecognition
//  - WithAttributes
//  - WithAlternateData
func (p *NoteStoreClient) GetResource(ctx context.Context, authenticationToken string, guid Types.Guid, withData bool, withRecognition bool, withAttributes bool, withAlternateData bool) (r *Types.Resource, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResource(ctx, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData); err != nil {
		return
	}
	return p.recvGetResource(ctx)
}

func (p *NoteStoreClient) sendGetResource(ctx context.Context, authenticationToken string, guid Types.Guid, withData bool, withRecognition bool, withAttributes bool, withAlternateData bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResource", thrift.CALL, p.SeqId)
	args213 := NewGetResourceArgs()
	args213.AuthenticationToken = authenticationToken
	args213.Guid = guid
	args213.WithData = withData
	args213.WithRecognition = withRecognition
	args213.WithAttributes = withAttributes
	args213.WithAlternateData = withAlternateData
	err = args213.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResource(ctx context.Context) (value *Types.Resource, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error215 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error216 error
		err = error215.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error216
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result214 := NewGetResourceResult()
	err = result214.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result214.Success
	if result214.UserException != nil {
		userException = result214.UserException
	}
	if result214.SystemException != nil {
		systemException = result214.SystemException
	}
	if result214.NotFoundException != nil {
		notFoundException = result214.NotFoundException
	}
	return
}

// Get all of the application data for the Resource identified by GUID,
// with values returned within the LazyMap fullMap field.
// If there are no applicationData entries, then a LazyMap
// with an empty fullMap will be returned. If your application
// only needs to fetch its own applicationData entry, use
// getResourceApplicationDataEntry instead.
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetResourceApplicationData(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.LazyMap, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceApplicationData(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetResourceApplicationData(ctx)
}

func (p *NoteStoreClient) sendGetResourceApplicationData(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceApplicationData", thrift.CALL, p.SeqId)
	args217 := NewGetResourceApplicationDataArgs()
	args217.AuthenticationToken = authenticationToken
	args217.Guid = guid
	err = args217.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceApplicationData(ctx context.Context) (value *Types.LazyMap, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error219 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error220 error
		err = error219.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error220
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result218 := NewGetResourceApplicationDataResult()
	err = result218.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result218.Success
	if result218.UserException != nil {
		userException = result218.UserException
	}
	if result218.SystemException != nil {
		systemException = result218.SystemException
	}
	if result218.NotFoundException != nil {
		notFoundException = result218.NotFoundException
	}
	return
}

// Get the value of a single entry in the applicationData map
// for the Resource identified by GUID.
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - Resource not found, by GUID</li>
//   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - Key
func (p *NoteStoreClient) GetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceApplicationDataEntry(ctx, authenticationToken, guid, key); err != nil {
		return
	}
	return p.recvGetResourceApplicationDataEntry(ctx)
}

func (p *NoteStoreClient) sendGetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceApplicationDataEntry", thrift.CALL, p.SeqId)
	args221 := NewGetResourceApplicationDataEntryArgs()
	args221.AuthenticationToken = authenticationToken
	args221.Guid = guid
	args221.Key = key
	err = args221.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceApplicationDataEntry(ctx context.Context) (value string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error223 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error224 error
		err = error223.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error224
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result222 := NewGetResourceApplicationDataEntryResult()
	err = result222.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result222.Success
	if result222.UserException != nil {
		userException = result222.UserException
	}
	if result222.SystemException != nil {
		systemException = result222.SystemException
	}
	if result222.NotFoundException != nil {
		notFoundException = result222.NotFoundException
	}
	return
}

// Update, or create, an entry in the applicationData map for
// the Resource identified by guid.
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - Key
//  - Value
func (p *NoteStoreClient) SetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string, value string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendSetResourceApplicationDataEntry(ctx, authenticationToken, guid, key, value); err != nil {
		return
	}
	return p.recvSetResourceApplicationDataEntry(ctx)
}

func (p *NoteStoreClient) sendSetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string, value string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "setResourceApplicationDataEntry", thrift.CALL, p.SeqId)
	args225 := NewSetResourceApplicationDataEntryArgs()
	args225.AuthenticationToken = authenticationToken
	args225.Guid = guid
	args225.Key = key
	args225.Value = value
	err = args225.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvSetResourceApplicationDataEntry(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error227 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error228 error
		err = error227.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error228
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result226 := NewSetResourceApplicationDataEntryResult()
	err = result226.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result226.Success
	if result226.UserException != nil {
		userException = result226.UserException
	}
	if result226.SystemException != nil {
		systemException = result226.SystemException
	}
	if result226.NotFoundException != nil {
		notFoundException = result226.NotFoundException
	}
	return
}

// Remove an entry identified by 'key' from the applicationData map for
// the Resource identified by 'guid'.
//
// Parameters:
//  - AuthenticationToken
//  - Guid
//  - Key
func (p *NoteStoreClient) UnsetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUnsetResourceApplicationDataEntry(ctx, authenticationToken, guid, key); err != nil {
		return
	}
	return p.recvUnsetResourceApplicationDataEntry(ctx)
}

func (p *NoteStoreClient) sendUnsetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid Types.Guid, key string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "unsetResourceApplicationDataEntry", thrift.CALL, p.SeqId)
	args229 := NewUnsetResourceApplicationDataEntryArgs()
	args229.AuthenticationToken = authenticationToken
	args229.Guid = guid
	args229.Key = key
	err = args229.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUnsetResourceApplicationDataEntry(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error231 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error232 error
		err = error231.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error232
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result230 := NewUnsetResourceApplicationDataEntryResult()
	err = result230.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result230.Success
	if result230.UserException != nil {
		userException = result230.UserException
	}
	if result230.SystemException != nil {
		systemException = result230.SystemException
	}
	if result230.NotFoundException != nil {
		notFoundException = result230.NotFoundException
	}
	return
}

// Submit a set of changes to a resource to the service.  This can be used
// to update the meta-data about the resource, but cannot be used to change
// the binary contents of the resource (including the length and hash).  These
// cannot be changed directly without creating a new resource and removing the
// old one via updateNote.
//
// @param resource
//   A Resource object containing the desired fields to be populated on
//   the service.  The service will attempt to update the resource with the
//   following fields from the client:
//   <ul>
//      <li>guid:  must be provided to identify the resource
//      </li>
//      <li>mime
//      </li>
//      <li>width
//      </li>
//      <li>height
//      </li>
//      <li>duration
//      </li>
//      <li>attributes:  optional.  if present, the set of attributes will
//           be replaced.
//      </li>
//   </ul>
//
// @return
//   The Update Sequence Number of the resource after the changes have been
//   applied.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
//   </li>
//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
//   </li>
//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Resource
func (p *NoteStoreClient) UpdateResource(ctx context.Context, authenticationToken string, resource *Types.Resource) (r int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendUpdateResource(ctx, authenticationToken, resource); err != nil {
		return
	}
	return p.recvUpdateResource(ctx)
}

func (p *NoteStoreClient) sendUpdateResource(ctx context.Context, authenticationToken string, resource *Types.Resource) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "updateResource", thrift.CALL, p.SeqId)
	args233 := NewUpdateResourceArgs()
	args233.AuthenticationToken = authenticationToken
	args233.Resource = resource
	err = args233.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUpdateResource(ctx context.Context) (value int32, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error235 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error236 error
		err = error235.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error236
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result234 := NewUpdateResourceResult()
	err = result234.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result234.Success
	if result234.UserException != nil {
		userException = result234.UserException
	}
	if result234.SystemException != nil {
		systemException = result234.SystemException
	}
	if result234.NotFoundException != nil {
		notFoundException = result234.NotFoundException
	}
	return
}

// Returns binary data of the resource with the provided GUID.  For
// example, if this were an image resource, this would contain the
// raw bits of the image.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
//
// @param guid
//   The GUID of the resource to be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetResourceData(ctx context.Context, authenticationToken string, guid Types.Guid) (r []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceData(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetResourceData(ctx)
}

func (p *NoteStoreClient) sendGetResourceData(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceData", thrift.CALL, p.SeqId)
	args237 := NewGetResourceDataArgs()
	args237.AuthenticationToken = authenticationToken
	args237.Guid = guid
	err = args237.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceData(ctx context.Context) (value []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error239 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error240 error
		err = error239.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error240
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result238 := NewGetResourceDataResult()
	err = result238.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result238.Success
	if result238.UserException != nil {
		userException = result238.UserException
	}
	if result238.SystemException != nil {
		systemException = result238.SystemException
	}
	if result238.NotFoundException != nil {
		notFoundException = result238.NotFoundException
	}
	return
}

// Returns the current state of a resource, referenced by containing
// note GUID and resource content hash.
//
// @param noteGuid
//   The GUID of the note that holds the resource to be retrieved.
//
// @param contentHash
//   The MD5 checksum of the resource within that note. Note that
//   this is the binary checksum, for example from Resource.data.bodyHash,
//   and not the hex-encoded checksum that is used within an en-media
//   tag in a note body.
//
// @param withData
//   If true, the Resource will include the binary contents of the
//   'data' field's body.
//
// @param withRecognition
//   If true, the Resource will include the binary contents of the
//   'recognition' field's body.
//
// @param withAlternateData
//   If true, the Resource will include the binary contents of the
//   'alternateData' field's body, if an alternate form is present.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
//   </li>
//   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note" - not found, by guid
//   </li>
//   <li> "Resource" - not found, by hash
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
//  - ContentHash
//  - WithData
//  - WithRecognition
//  - WithAlternateData
func (p *NoteStoreClient) GetResourceByHash(ctx context.Context, authenticationToken string, noteGuid Types.Guid, contentHash []byte, withData bool, withRecognition bool, withAlternateData bool) (r *Types.Resource, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceByHash(ctx, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData); err != nil {
		return
	}
	return p.recvGetResourceByHash(ctx)
}

func (p *NoteStoreClient) sendGetResourceByHash(ctx context.Context, authenticationToken string, noteGuid Types.Guid, contentHash []byte, withData bool, withRecognition bool, withAlternateData bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceByHash", thrift.CALL, p.SeqId)
	args241 := NewGetResourceByHashArgs()
	args241.AuthenticationToken = authenticationToken
	args241.NoteGuid = noteGuid
	args241.ContentHash = contentHash
	args241.WithData = withData
	args241.WithRecognition = withRecognition
	args241.WithAlternateData = withAlternateData
	err = args241.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceByHash(ctx context.Context) (value *Types.Resource, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error243 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error244 error
		err = error243.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error244
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result242 := NewGetResourceByHashResult()
	err = result242.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result242.Success
	if result242.UserException != nil {
		userException = result242.UserException
	}
	if result242.SystemException != nil {
		systemException = result242.SystemException
	}
	if result242.NotFoundException != nil {
		notFoundException = result242.NotFoundException
	}
	return
}

// Returns the binary contents of the recognition index for the resource
// with the provided GUID.  If the caller asks about a resource that has
// no recognition data, this will throw EDAMNotFoundException.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
//
// @param guid
//   The GUID of the resource whose recognition data should be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
//   <li> "Resource.recognition" - resource has no recognition
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetResourceRecognition(ctx context.Context, authenticationToken string, guid Types.Guid) (r []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceRecognition(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetResourceRecognition(ctx)
}

func (p *NoteStoreClient) sendGetResourceRecognition(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceRecognition", thrift.CALL, p.SeqId)
	args245 := NewGetResourceRecognitionArgs()
	args245.AuthenticationToken = authenticationToken
	args245.Guid = guid
	err = args245.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceRecognition(ctx context.Context) (value []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error247 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error248 error
		err = error247.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error248
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result246 := NewGetResourceRecognitionResult()
	err = result246.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result246.Success
	if result246.UserException != nil {
		userException = result246.UserException
	}
	if result246.SystemException != nil {
		systemException = result246.SystemException
	}
	if result246.NotFoundException != nil {
		notFoundException = result246.NotFoundException
	}
	return
}

// If the Resource with the provided GUID has an alternate data representation
// (indicated via the Resource.alternateData field), then this request can
// be used to retrieve the binary contents of that alternate data file.
// If the caller asks about a resource that has no alternate data form, this
// will throw EDAMNotFoundException.
//
// @param guid
//    The GUID of the resource whose recognition data should be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
//   <li> "Resource.alternateData" - resource has no recognition
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetResourceAlternateData(ctx context.Context, authenticationToken string, guid Types.Guid) (r []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceAlternateData(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetResourceAlternateData(ctx)
}

func (p *NoteStoreClient) sendGetResourceAlternateData(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceAlternateData", thrift.CALL, p.SeqId)
	args249 := NewGetResourceAlternateDataArgs()
	args249.AuthenticationToken = authenticationToken
	args249.Guid = guid
	err = args249.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceAlternateData(ctx context.Context) (value []byte, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error251 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error252 error
		err = error251.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error252
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result250 := NewGetResourceAlternateDataResult()
	err = result250.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result250.Success
	if result250.UserException != nil {
		userException = result250.UserException
	}
	if result250.SystemException != nil {
		systemException = result250.SystemException
	}
	if result250.NotFoundException != nil {
		notFoundException = result250.NotFoundException
	}
	return
}

// Returns the set of attributes for the Resource with the provided GUID.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
//
// @param guid
//   The GUID of the resource whose attributes should be retrieved.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) GetResourceAttributes(ctx context.Context, authenticationToken string, guid Types.Guid) (r *Types.ResourceAttributes, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetResourceAttributes(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvGetResourceAttributes(ctx)
}

func (p *NoteStoreClient) sendGetResourceAttributes(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getResourceAttributes", thrift.CALL, p.SeqId)
	args253 := NewGetResourceAttributesArgs()
	args253.AuthenticationToken = authenticationToken
	args253.Guid = guid
	err = args253.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetResourceAttributes(ctx context.Context) (value *Types.ResourceAttributes, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error255 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error256 error
		err = error255.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error256
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result254 := NewGetResourceAttributesResult()
	err = result254.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result254.Success
	if result254.UserException != nil {
		userException = result254.UserException
	}
	if result254.SystemException != nil {
		systemException = result254.SystemException
	}
	if result254.NotFoundException != nil {
		notFoundException = result254.NotFoundException
	}
	return
}

// <p>
// Looks for a user account with the provided userId on this NoteStore
// shard and determines whether that account contains a public notebook
// with the given URI.  If the account is not found, or no public notebook
// exists with this URI, this will throw an EDAMNotFoundException,
// otherwise this will return the information for that Notebook.
// </p>
// <p>
// If a notebook is visible on the web with a full URL like
// http://www.evernote.com/pub/sethdemo/api
// Then 'sethdemo' is the username that can be used to look up the userId,
// and 'api' is the publicUri.
// </p>
//
// @param userId
//    The numeric identifier for the user who owns the public notebook.
//    To find this value based on a username string, you can invoke
//    UserStore.getPublicUserInfo
//
// @param publicUri
//    The uri string for the public notebook, from Notebook.publishing.uri.
//
// @throws EDAMNotFoundException <ul>
//   <li>"Publishing.uri" - not found, by URI</li>
// </ul>
//
// @throws EDAMSystemException <ul>
//   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
//     taken down (for all requesters).</li>
//   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
//     down for the requester because of an IP-based country lookup.</li>
// </ul>
//
// Parameters:
//  - UserId
//  - PublicUri
func (p *NoteStoreClient) GetPublicNotebook(ctx context.Context, userId Types.UserID, publicUri string) (r *Types.Notebook, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendGetPublicNotebook(ctx, userId, publicUri); err != nil {
		return
	}
	return p.recvGetPublicNotebook(ctx)
}

func (p *NoteStoreClient) sendGetPublicNotebook(ctx context.Context, userId Types.UserID, publicUri string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getPublicNotebook", thrift.CALL, p.SeqId)
	args257 := NewGetPublicNotebookArgs()
	args257.UserId = userId
	args257.PublicUri = publicUri
	err = args257.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetPublicNotebook(ctx context.Context) (value *Types.Notebook, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error259 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error260 error
		err = error259.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error260
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result258 := NewGetPublicNotebookResult()
	err = result258.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result258.Success
	if result258.SystemException != nil {
		systemException = result258.SystemException
	}
	if result258.NotFoundException != nil {
		notFoundException = result258.NotFoundException
	}
	return
}

// Used to construct a shared notebook object. The constructed notebook will
// contain a "share key" which serve as a unique identifer and access token
// for a user to access the notebook of the shared notebook owner.
//
// @param sharedNotebook
//   A shared notebook object populated with the email address of the share
//   recipient, the notebook guid and the access permissions. All other
//   attributes of the shared object are ignored. The SharedNotebook.allowPreview
//   field must be explicitly set with either a true or false value.
//
// @return
//   The fully populated SharedNotebook object including the server assigned
//   share id and shareKey which can both be used to uniquely identify the
//   SharedNotebook.
//
// @throws EDAMUserException <ul>
//   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
//   <li>BAD_DATA_FORMAT "requireLogin" - if the SharedNotebook.allowPreview field was
//       not set, and the SharedNotebook.requireLogin was also not set or was set to
//       false.</li>
//   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
//       recipientSettings is set in the sharedNotebook.  Only the recipient
//       can set these values via the setSharedNotebookRecipientSettings
//       method.
//   </li>
//   </ul>
// @throws EDAMNotFoundException <ul>
//   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
//   </li>
//   </ul>
//
// Parameters:
//  - AuthenticationToken
//  - SharedNotebook
func (p *NoteStoreClient) CreateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *Types.SharedNotebook) (r *Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendCreateSharedNotebook(ctx, authenticationToken, sharedNotebook); err != nil {
		return
	}
	return p.recvCreateSharedNotebook(ctx)
}

func (p *NoteStoreClient) sendCreateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *Types.SharedNotebook) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "createSharedNotebook", thrift.CALL, p.SeqId)
	args261 := NewCreateSharedNotebookArgs()
	args261.AuthenticationToken = authenticationToken
	args261.SharedNotebook = sharedNotebook
	err = args261.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvCreateSharedNotebook(ctx context.Context) (value *Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error263 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error264 error
		err = error263.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error264
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result262 := NewCreateSharedNotebookResult()
	err = result262.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result262.Success
	if result262.UserException != nil {
		userException = result262.UserException
	}
	if result262.NotFoundException != nil {
		notFoundException = result262.NotFoundException
	}
	if result262.SystemException != nil {
		systemException = result262.SystemException
	}
	return
}

// Update a SharedNotebook object.
//
// @param authenticationToken
//   Must be an authentication token from the owner or a shared notebook
//   authentication token or business authentication token with sufficient
//   permissions to change invitations for a notebook.
//
// @param sharedNotebook
//  The SharedNotebook object containing the requested changes.
//  The "id" of the shared notebook must be set to allow the service
//  to identify the SharedNotebook to be updated. In addition, you MUST set
//  the email, permission, and allowPreview fields to the desired values.
//  All other fields will be ignored if set.
//
// @return
//  The Update Serial Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li>UNSUPPORTED_OPERATION "updateSharedNotebook" - if this service instance does not support shared notebooks.</li>
//   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid.</li>
//   <li>DATA_REQUIRED "SharedNotebook.id" - if the id field was not set.</li>
//   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the privilege field was not set.</li>
//   <li>DATA_REQUIRED "SharedNotebook.allowPreview" - if the allowPreview field was not set.</li>
//   </ul>
// @throws EDAMNotFoundException <ul>
//   <li>SharedNotebook.id - if no shared notebook with the specified ID was found.
//   </ul>
//
// Parameters:
//  - AuthenticationToken
//  - SharedNotebook
func (p *NoteStoreClient) UpdateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *Types.SharedNotebook) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendUpdateSharedNotebook(ctx, authenticationToken, sharedNotebook); err != nil {
		return
	}
	return p.recvUpdateSharedNotebook(ctx)
}

func (p *NoteStoreClient) sendUpdateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *Types.SharedNotebook) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "updateSharedNotebook", thrift.CALL, p.SeqId)
	args265 := NewUpdateSharedNotebookArgs()
	args265.AuthenticationToken = authenticationToken
	args265.SharedNotebook = sharedNotebook
	err = args265.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUpdateSharedNotebook(ctx context.Context) (value int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error267 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error268 error
		err = error267.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error268
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result266 := NewUpdateSharedNotebookResult()
	err = result266.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result266.Success
	if result266.UserException != nil {
		userException = result266.UserException
	}
	if result266.NotFoundException != nil {
		notFoundException = result266.NotFoundException
	}
	if result266.SystemException != nil {
		systemException = result266.SystemException
	}
	return
}

// Set values for the recipient settings associated with a shared notebook.  Having
// update rights to the shared notebook record itself has no effect on this call;
// only the recipient of the shared notebook can can the recipient settings.
//
// If you do <i>not</i> wish to, or cannot, change one of the reminderNotifyEmail or
// reminderNotifyInApp fields, you must leave that field unset in recipientSettings.
// This method will skip that field for updates and leave the existing state as
// it is.
//
// @return The update sequence number of the account to which the shared notebook
//   belongs, which is the account from which we are sharing a notebook.
//
// @throws EDAMNotFoundException "sharedNotebookId" - Thrown if the service does not
//   have a shared notebook record for the sharedNotebookId on the given shard.  If you
//   receive this exception, it is probable that the shared notebook record has
//   been revoked or expired, or that you accessed the wrong shard.
//
// @throws EDAMUserException <ul>
//   <li>PEMISSION_DENIED "authenticationToken" - If you do not have permission to set
//       the recipient settings for the shared notebook.  Only the recipient has
//       permission to do this.
//   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting whether
//       or not you want to receive reminder e-mail notifications is possible on
//       a business notebook in the business to which the user belongs.  All
//       others can safely unset the reminderNotifyEmail field from the
//       recipientSettings parameter.
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - SharedNotebookId
//  - RecipientSettings
func (p *NoteStoreClient) SetSharedNotebookRecipientSettings(ctx context.Context, authenticationToken string, sharedNotebookId int64, recipientSettings *Types.SharedNotebookRecipientSettings) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendSetSharedNotebookRecipientSettings(ctx, authenticationToken, sharedNotebookId, recipientSettings); err != nil {
		return
	}
	return p.recvSetSharedNotebookRecipientSettings(ctx)
}

func (p *NoteStoreClient) sendSetSharedNotebookRecipientSettings(ctx context.Context, authenticationToken string, sharedNotebookId int64, recipientSettings *Types.SharedNotebookRecipientSettings) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "setSharedNotebookRecipientSettings", thrift.CALL, p.SeqId)
	args269 := NewSetSharedNotebookRecipientSettingsArgs()
	args269.AuthenticationToken = authenticationToken
	args269.SharedNotebookId = sharedNotebookId
	args269.RecipientSettings = recipientSettings
	err = args269.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvSetSharedNotebookRecipientSettings(ctx context.Context) (value int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error271 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error272 error
		err = error271.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error272
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result270 := NewSetSharedNotebookRecipientSettingsResult()
	err = result270.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result270.Success
	if result270.UserException != nil {
		userException = result270.UserException
	}
	if result270.NotFoundException != nil {
		notFoundException = result270.NotFoundException
	}
	if result270.SystemException != nil {
		systemException = result270.SystemException
	}
	return
}

// Send a reminder message to some or all of the email addresses that a notebook has been
// shared with. The message includes the current link to view the notebook.
// @param authenticationToken
//   The auth token of the user with permissions to share the notebook
// @param notebookGuid
//   The guid of the shared notebook
// @param messageText
//  User provided text to include in the email
// @param recipients
//  The email addresses of the recipients. If this list is empty then all of the
//  users that the notebook has been shared with are emailed.
//  If an email address doesn't correspond to share invite members then that address
//  is ignored.
// @return
//  The number of messages sent
// @throws EDAMUserException <ul>
//   <li> LIMIT_REACHED "(recipients)" -
//     The email can't be sent because this would exceed the user's daily
//     email limit.
//   </li>
//   <li> PERMISSION_DENIED "Notebook.guid" - The user doesn't have permission to
//     send a message for the specified notebook.
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - NotebookGuid
//  - MessageText
//  - Recipients
func (p *NoteStoreClient) SendMessageToSharedNotebookMembers(ctx context.Context, authenticationToken string, notebookGuid Types.Guid, messageText string, recipients []string) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendSendMessageToSharedNotebookMembers(ctx, authenticationToken, notebookGuid, messageText, recipients); err != nil {
		return
	}
	return p.recvSendMessageToSharedNotebookMembers(ctx)
}

func (p *NoteStoreClient) sendSendMessageToSharedNotebookMembers(ctx context.Context, authenticationToken string, notebookGuid Types.Guid, messageText string, recipients []string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "sendMessageToSharedNotebookMembers", thrift.CALL, p.SeqId)
	args273 := NewSendMessageToSharedNotebookMembersArgs()
	args273.AuthenticationToken = authenticationToken
	args273.NotebookGuid = notebookGuid
	args273.MessageText = messageText
	args273.Recipients = recipients
	err = args273.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvSendMessageToSharedNotebookMembers(ctx context.Context) (value int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error275 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error276 error
		err = error275.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error276
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result274 := NewSendMessageToSharedNotebookMembersResult()
	err = result274.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result274.Success
	if result274.UserException != nil {
		userException = result274.UserException
	}
	if result274.NotFoundException != nil {
		notFoundException = result274.NotFoundException
	}
	if result274.SystemException != nil {
		systemException = result274.SystemException
	}
	return
}

// Lists the collection of shared notebooks for all notebooks in the
// users account.
//
// @return
//  The list of all SharedNotebooks for the user
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListSharedNotebooks(ctx context.Context, authenticationToken string) (r []*Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendListSharedNotebooks(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvListSharedNotebooks(ctx)
}

func (p *NoteStoreClient) sendListSharedNotebooks(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "listSharedNotebooks", thrift.CALL, p.SeqId)
	args277 := NewListSharedNotebooksArgs()
	args277.AuthenticationToken = authenticationToken
	err = args277.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvListSharedNotebooks(ctx context.Context) (value []*Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error279 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error280 error
		err = error279.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error280
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result278 := NewListSharedNotebooksResult()
	err = result278.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result278.Success
	if result278.UserException != nil {
		userException = result278.UserException
	}
	if result278.NotFoundException != nil {
		notFoundException = result278.NotFoundException
	}
	if result278.SystemException != nil {
		systemException = result278.SystemException
	}
	return
}

// Expunges the SharedNotebooks in the user's account using the
// SharedNotebook.id as the identifier.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param
//   sharedNotebookIds - a list of ShardNotebook.id longs identifying the
//       objects to delete permanently.
//
// @return
//   The account's update sequence number.
//
// Parameters:
//  - AuthenticationToken
//  - SharedNotebookIds
func (p *NoteStoreClient) ExpungeSharedNotebooks(ctx context.Context, authenticationToken string, sharedNotebookIds []int64) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendExpungeSharedNotebooks(ctx, authenticationToken, sharedNotebookIds); err != nil {
		return
	}
	return p.recvExpungeSharedNotebooks(ctx)
}

func (p *NoteStoreClient) sendExpungeSharedNotebooks(ctx context.Context, authenticationToken string, sharedNotebookIds []int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeSharedNotebooks", thrift.CALL, p.SeqId)
	args281 := NewExpungeSharedNotebooksArgs()
	args281.AuthenticationToken = authenticationToken
	args281.SharedNotebookIds = sharedNotebookIds
	err = args281.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeSharedNotebooks(ctx context.Context) (value int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error283 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error284 error
		err = error283.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error284
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result282 := NewExpungeSharedNotebooksResult()
	err = result282.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result282.Success
	if result282.UserException != nil {
		userException = result282.UserException
	}
	if result282.NotFoundException != nil {
		notFoundException = result282.NotFoundException
	}
	if result282.SystemException != nil {
		systemException = result282.SystemException
	}
	return
}

// Asks the service to make a linked notebook with the provided name, username
// of the owner and identifiers provided. A linked notebook can be either a
// link to a public notebook or to a private shared notebook.
//
// @param linkedNotebook
//   The desired fields for the linked notebook must be provided on this
//   object.  The name of the linked notebook must be set. Either a username
//   uri or a shard id and share key must be provided otherwise a
//   EDAMUserException is thrown.
//
// @return
//   The newly created LinkedNotebook.  The server-side id will be
//   saved in this object's 'id' field.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
//     if public notebook set but bad uri
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.shareKey" -
//     if private notebook set but bad shareKey
//   </li>
//   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
//     if private notebook but shard id not provided
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
func (p *NoteStoreClient) CreateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (r *Types.LinkedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendCreateLinkedNotebook(ctx, authenticationToken, linkedNotebook); err != nil {
		return
	}
	return p.recvCreateLinkedNotebook(ctx)
}

func (p *NoteStoreClient) sendCreateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "createLinkedNotebook", thrift.CALL, p.SeqId)
	args285 := NewCreateLinkedNotebookArgs()
	args285.AuthenticationToken = authenticationToken
	args285.LinkedNotebook = linkedNotebook
	err = args285.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvCreateLinkedNotebook(ctx context.Context) (value *Types.LinkedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error287 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error288 error
		err = error287.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error288
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result286 := NewCreateLinkedNotebookResult()
	err = result286.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result286.Success
	if result286.UserException != nil {
		userException = result286.UserException
	}
	if result286.NotFoundException != nil {
		notFoundException = result286.NotFoundException
	}
	if result286.SystemException != nil {
		systemException = result286.SystemException
	}
	return
}

// @param linkedNotebook
//   Updates the name of a linked notebook.
//
// @return
//   The Update Sequence Number for this change within the account.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
func (p *NoteStoreClient) UpdateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendUpdateLinkedNotebook(ctx, authenticationToken, linkedNotebook); err != nil {
		return
	}
	return p.recvUpdateLinkedNotebook(ctx)
}

func (p *NoteStoreClient) sendUpdateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *Types.LinkedNotebook) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "updateLinkedNotebook", thrift.CALL, p.SeqId)
	args289 := NewUpdateLinkedNotebookArgs()
	args289.AuthenticationToken = authenticationToken
	args289.LinkedNotebook = linkedNotebook
	err = args289.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvUpdateLinkedNotebook(ctx context.Context) (value int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error291 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error292 error
		err = error291.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error292
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result290 := NewUpdateLinkedNotebookResult()
	err = result290.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result290.Success
	if result290.UserException != nil {
		userException = result290.UserException
	}
	if result290.NotFoundException != nil {
		notFoundException = result290.NotFoundException
	}
	if result290.SystemException != nil {
		systemException = result290.SystemException
	}
	return
}

// Returns a list of linked notebooks
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListLinkedNotebooks(ctx context.Context, authenticationToken string) (r []*Types.LinkedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendListLinkedNotebooks(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvListLinkedNotebooks(ctx)
}

func (p *NoteStoreClient) sendListLinkedNotebooks(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "listLinkedNotebooks", thrift.CALL, p.SeqId)
	args293 := NewListLinkedNotebooksArgs()
	args293.AuthenticationToken = authenticationToken
	err = args293.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvListLinkedNotebooks(ctx context.Context) (value []*Types.LinkedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error295 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error296 error
		err = error295.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error296
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result294 := NewListLinkedNotebooksResult()
	err = result294.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result294.Success
	if result294.UserException != nil {
		userException = result294.UserException
	}
	if result294.NotFoundException != nil {
		notFoundException = result294.NotFoundException
	}
	if result294.SystemException != nil {
		systemException = result294.SystemException
	}
	return
}

// Permanently expunges the linked notebook from the account.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param guid
//   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
//   from the account.
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) ExpungeLinkedNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (r int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendExpungeLinkedNotebook(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvExpungeLinkedNotebook(ctx)
}

func (p *NoteStoreClient) sendExpungeLinkedNotebook(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "expungeLinkedNotebook", thrift.CALL, p.SeqId)
	args297 := NewExpungeLinkedNotebookArgs()
	args297.AuthenticationToken = authenticationToken
	args297.Guid = guid
	err = args297.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvExpungeLinkedNotebook(ctx context.Context) (value int32, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error299 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error300 error
		err = error299.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error300
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result298 := NewExpungeLinkedNotebookResult()
	err = result298.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result298.Success
	if result298.UserException != nil {
		userException = result298.UserException
	}
	if result298.NotFoundException != nil {
		notFoundException = result298.NotFoundException
	}
	if result298.SystemException != nil {
		systemException = result298.SystemException
	}
	return
}

// Asks the service to produce an authentication token that can be used to
// access the contents of a shared notebook from someone else's account.
// This authenticationToken can be used with the various other NoteStore
// calls to find and retrieve notes, and if the permissions in the shared
// notebook are sufficient, to make changes to the contents of the notebook.
//
// @param shareKey
//   The 'shareKey' identifier from the SharedNotebook that was granted to
//   some recipient.  This string internally encodes the notebook identifier
//   and a security signature.
//
// @param authenticationToken
//   If a non-empty string is provided, this is the full user-based
//   authentication token that identifies the user who is currently logged in
//   and trying to access the shared notebook.  This may be required if the
//   notebook was created with 'requireLogin'.
//   If this string is empty, the service will attempt to authenticate to the
//   shared notebook without any logged in user.
//
// @throws EDAMSystemException <ul>
//   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string
//   </li>
//   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "SharedNotebook.id" - the shared notebook no longer exists
//   </li>
// </ul>
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
//          no valid authentication token was provided.
//   </li>
//   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
//          and another username has already been bound to this notebook.
//   </li>
// </ul>
//
// Parameters:
//  - ShareKey
//  - AuthenticationToken
func (p *NoteStoreClient) AuthenticateToSharedNotebook(ctx context.Context, shareKey string, authenticationToken string) (r *UserStore.AuthenticationResult, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendAuthenticateToSharedNotebook(ctx, shareKey, authenticationToken); err != nil {
		return
	}
	return p.recvAuthenticateToSharedNotebook(ctx)
}

func (p *NoteStoreClient) sendAuthenticateToSharedNotebook(ctx context.Context, shareKey string, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "authenticateToSharedNotebook", thrift.CALL, p.SeqId)
	args301 := NewAuthenticateToSharedNotebookArgs()
	args301.ShareKey = shareKey
	args301.AuthenticationToken = authenticationToken
	err = args301.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvAuthenticateToSharedNotebook(ctx context.Context) (value *UserStore.AuthenticationResult, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error303 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error304 error
		err = error303.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error304
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result302 := NewAuthenticateToSharedNotebookResult()
	err = result302.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result302.Success
	if result302.UserException != nil {
		userException = result302.UserException
	}
	if result302.NotFoundException != nil {
		notFoundException = result302.NotFoundException
	}
	if result302.SystemException != nil {
		systemException = result302.SystemException
	}
	return
}

// This function is used to retrieve extended information about a shared
// notebook by a guest who has already authenticated to access that notebook.
// This requires an 'authenticationToken' parameter which should be the
// resut of a call to authenticateToSharedNotebook(...).
// I.e. this is the token that gives access to the particular shared notebook
// in someone else's account -- it's not the authenticationToken for the
// owner of the notebook itself.
//
// @param authenticationToken
//   Should be the authentication token retrieved from the reply of
//   authenticateToSharedNotebook(ctx), proving access to a particular shared
//   notebook.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "authenticationToken" -
//          authentication token doesn't correspond to a valid shared notebook
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "SharedNotebook.id" - the shared notebook no longer exists
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) GetSharedNotebookByAuth(ctx context.Context, authenticationToken string) (r *Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetSharedNotebookByAuth(ctx, authenticationToken); err != nil {
		return
	}
	return p.recvGetSharedNotebookByAuth(ctx)
}

func (p *NoteStoreClient) sendGetSharedNotebookByAuth(ctx context.Context, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "getSharedNotebookByAuth", thrift.CALL, p.SeqId)
	args305 := NewGetSharedNotebookByAuthArgs()
	args305.AuthenticationToken = authenticationToken
	err = args305.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvGetSharedNotebookByAuth(ctx context.Context) (value *Types.SharedNotebook, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error307 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error308 error
		err = error307.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error308
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result306 := NewGetSharedNotebookByAuthResult()
	err = result306.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result306.Success
	if result306.UserException != nil {
		userException = result306.UserException
	}
	if result306.NotFoundException != nil {
		notFoundException = result306.NotFoundException
	}
	if result306.SystemException != nil {
		systemException = result306.SystemException
	}
	return
}

// Attempts to send a single note to one or more email recipients.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
//
// @param authenticationToken
//    The note will be sent as the user logged in via this token, using that
//    user's registered email address.  If the authenticated user doesn't
//    have permission to read that note, the emailing will fail.
//
// @param parameters
//    The note must be specified either by GUID (in which case it will be
//    sent using the existing data in the service), or else the full Note
//    must be passed to this call.  This also specifies the additional
//    email fields that will be used in the email.
//
// @throws EDAMUserException <ul>
//   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
//     The email can't be sent because this would exceed the user's daily
//     email limit.
//   </li>
//   <li> BAD_DATA_FORMAT "(email address)" -
//     email address malformed
//   </li>
//   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
//     if there are no To: or Cc: addresses provided.
//   </li>
//   <li> DATA_REQUIRED "Note.title" -
//     if the caller provides a Note parameter with no title
//   </li>
//   <li> DATA_REQUIRED "Note.content" -
//     if the caller provides a Note parameter with no content
//   </li>
//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
//   </li>
//   <li> DATA_REQUIRED "NoteEmailParameters.note" -
//     if no guid or note provided
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Parameters
func (p *NoteStoreClient) EmailNote(ctx context.Context, authenticationToken string, parameters *NoteEmailParameters) (userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendEmailNote(ctx, authenticationToken, parameters); err != nil {
		return
	}
	return p.recvEmailNote(ctx)
}

func (p *NoteStoreClient) sendEmailNote(ctx context.Context, authenticationToken string, parameters *NoteEmailParameters) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "emailNote", thrift.CALL, p.SeqId)
	args309 := NewEmailNoteArgs()
	args309.AuthenticationToken = authenticationToken
	args309.Parameters = parameters
	err = args309.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvEmailNote(ctx context.Context) (userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error311 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error312 error
		err = error311.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error312
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result310 := NewEmailNoteResult()
	err = result310.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	if result310.UserException != nil {
		userException = result310.UserException
	}
	if result310.NotFoundException != nil {
		notFoundException = result310.NotFoundException
	}
	if result310.SystemException != nil {
		systemException = result310.SystemException
	}
	return
}

// If this note is not already shared (via its own direct URL), then this
// will start sharing that note.
// This will return the secret "Note Key" for this note that
// can currently be used in conjunction with the Note's GUID to gain direct
// read-only access to the Note.
// If the note is already shared, then this won't make any changes to the
// note, and the existing "Note Key" will be returned.  The only way to change
// the Note Key for an existing note is to stopSharingNote first, and then
// call this function.
//
// @param guid
//   The GUID of the note to be shared.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) ShareNote(ctx context.Context, authenticationToken string, guid Types.Guid) (r string, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendShareNote(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvShareNote(ctx)
}

func (p *NoteStoreClient) sendShareNote(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "shareNote", thrift.CALL, p.SeqId)
	args313 := NewShareNoteArgs()
	args313.AuthenticationToken = authenticationToken
	args313.Guid = guid
	err = args313.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvShareNote(ctx context.Context) (value string, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error315 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error316 error
		err = error315.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error316
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result314 := NewShareNoteResult()
	err = result314.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result314.Success
	if result314.UserException != nil {
		userException = result314.UserException
	}
	if result314.NotFoundException != nil {
		notFoundException = result314.NotFoundException
	}
	if result314.SystemException != nil {
		systemException = result314.SystemException
	}
	return
}

// If this note is not already shared then this will stop sharing that note
// and invalidate its "Note Key", so any existing URLs to access that Note
// will stop working.
// If the Note is not shared, then this function will do nothing.
//
// @param guid
//   The GUID of the note to be un-shared.
//
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Guid
func (p *NoteStoreClient) StopSharingNote(ctx context.Context, authenticationToken string, guid Types.Guid) (userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendStopSharingNote(ctx, authenticationToken, guid); err != nil {
		return
	}
	return p.recvStopSharingNote(ctx)
}

func (p *NoteStoreClient) sendStopSharingNote(ctx context.Context, authenticationToken string, guid Types.Guid) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "stopSharingNote", thrift.CALL, p.SeqId)
	args317 := NewStopSharingNoteArgs()
	args317.AuthenticationToken = authenticationToken
	args317.Guid = guid
	err = args317.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvStopSharingNote(ctx context.Context) (userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error319 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error320 error
		err = error319.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error320
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result318 := NewStopSharingNoteResult()
	err = result318.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	if result318.UserException != nil {
		userException = result318.UserException
	}
	if result318.NotFoundException != nil {
		notFoundException = result318.NotFoundException
	}
	if result318.SystemException != nil {
		systemException = result318.SystemException
	}
	return
}

// Asks the service to produce an authentication token that can be used to
// access the contents of a single Note which was individually shared
// from someone's account.
// This authenticationToken can be used with the various other NoteStore
// calls to find and retrieve the Note and its directly-referenced children.
//
// @param guid
//   The GUID identifying this Note on this shard.
//
// @param noteKey
//   The 'noteKey' identifier from the Note that was originally created via
//   a call to shareNote() and then given to a recipient to access.
//
// @param authenticationToken
//   An optional authenticationToken that identifies the user accessing the
//   shared note. This parameter may be required to access some shared notes.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
//     shared, or the noteKey doesn't match the current key for this note
//   </li>
//   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
//     required to access this Note, but either no authentication token or a
//     "non-owner" authentication token was provided.
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li> "guid" - the note with that GUID is not found
//   </li>
// </ul>
//
// @throws EDAMSystemException <ul>
//   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
//     all requesters).
//   </li>
//   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
//     for the requester because of an IP-based country lookup.
//   </ul>
// </ul>
//
// Parameters:
//  - Guid
//  - NoteKey
//  - AuthenticationToken
func (p *NoteStoreClient) AuthenticateToSharedNote(ctx context.Context, guid string, noteKey string, authenticationToken string) (r *UserStore.AuthenticationResult, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendAuthenticateToSharedNote(ctx, guid, noteKey, authenticationToken); err != nil {
		return
	}
	return p.recvAuthenticateToSharedNote(ctx)
}

func (p *NoteStoreClient) sendAuthenticateToSharedNote(ctx context.Context, guid string, noteKey string, authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "authenticateToSharedNote", thrift.CALL, p.SeqId)
	args321 := NewAuthenticateToSharedNoteArgs()
	args321.Guid = guid
	args321.NoteKey = noteKey
	args321.AuthenticationToken = authenticationToken
	err = args321.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvAuthenticateToSharedNote(ctx context.Context) (value *UserStore.AuthenticationResult, userException *Errors.EDAMUserException, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error323 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error324 error
		err = error323.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error324
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result322 := NewAuthenticateToSharedNoteResult()
	err = result322.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result322.Success
	if result322.UserException != nil {
		userException = result322.UserException
	}
	if result322.NotFoundException != nil {
		notFoundException = result322.NotFoundException
	}
	if result322.SystemException != nil {
		systemException = result322.SystemException
	}
	return
}

// Identify related entities on the service, such as notes,
// notebooks, and tags related to notes or content.
//
// @param query
//   The information about which we are finding related entities.
//
// @param resultSpec
//   Allows the client to indicate the type and quantity of
//   information to be returned, allowing a saving of time and
//   bandwidth.
//
// @return
//   The result of the query, with information considered
//   to likely be relevantly related to the information
//   described by the query.
//
// @throws EDAMUserException <ul>
//   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
//     a zero-length plain text value.
//   </li>
//   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
//     invalid Note GUID, that is, one that does not match the constraints
//     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
//   </li>
//   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
//     the note identified by RelatedQuery.noteGuid.
//   </li>
//   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
//     in the result spec.
//   </li>
// </ul>
//
// @throws EDAMNotFoundException <ul>
//   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
//     found, if that field has been set in the query.
//   </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - Query
//  - ResultSpec
func (p *NoteStoreClient) FindRelated(ctx context.Context, authenticationToken string, query *RelatedQuery, resultSpec *RelatedResultSpec) (r *RelatedResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	if err = p.sendFindRelated(ctx, authenticationToken, query, resultSpec); err != nil {
		return
	}
	return p.recvFindRelated(ctx)
}

func (p *NoteStoreClient) sendFindRelated(ctx context.Context, authenticationToken string, query *RelatedQuery, resultSpec *RelatedResultSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin(ctx, "findRelated", thrift.CALL, p.SeqId)
	args325 := NewFindRelatedArgs()
	args325.AuthenticationToken = authenticationToken
	args325.Query = query
	args325.ResultSpec = resultSpec
	err = args325.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return
}

func (p *NoteStoreClient) recvFindRelated(ctx context.Context) (value *RelatedResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, notFoundException *Errors.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin(ctx)
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error327 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error328 error
		err = error327.Read(ctx, iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(ctx); err != nil {
			return
		}
		err = error328
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result326 := NewFindRelatedResult()
	err = result326.Read(ctx, iprot)
	iprot.ReadMessageEnd(ctx)
	value = result326.Success
	if result326.UserException != nil {
		userException = result326.UserException
	}
	if result326.SystemException != nil {
		systemException = result326.SystemException
	}
	if result326.NotFoundException != nil {
		notFoundException = result326.NotFoundException
	}
	return
}

type NoteStoreProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      NoteStore
}

func (p *NoteStoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *NoteStoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *NoteStoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewNoteStoreProcessor(handler NoteStore) *NoteStoreProcessor {

	self329 := &NoteStoreProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self329.processorMap["getSyncState"] = &noteStoreProcessorGetSyncState{handler: handler}
	self329.processorMap["getSyncStateWithMetrics"] = &noteStoreProcessorGetSyncStateWithMetrics{handler: handler}
	self329.processorMap["getSyncChunk"] = &noteStoreProcessorGetSyncChunk{handler: handler}
	self329.processorMap["getFilteredSyncChunk"] = &noteStoreProcessorGetFilteredSyncChunk{handler: handler}
	self329.processorMap["getLinkedNotebookSyncState"] = &noteStoreProcessorGetLinkedNotebookSyncState{handler: handler}
	self329.processorMap["getLinkedNotebookSyncChunk"] = &noteStoreProcessorGetLinkedNotebookSyncChunk{handler: handler}
	self329.processorMap["listNotebooks"] = &noteStoreProcessorListNotebooks{handler: handler}
	self329.processorMap["getNotebook"] = &noteStoreProcessorGetNotebook{handler: handler}
	self329.processorMap["getDefaultNotebook"] = &noteStoreProcessorGetDefaultNotebook{handler: handler}
	self329.processorMap["createNotebook"] = &noteStoreProcessorCreateNotebook{handler: handler}
	self329.processorMap["updateNotebook"] = &noteStoreProcessorUpdateNotebook{handler: handler}
	self329.processorMap["expungeNotebook"] = &noteStoreProcessorExpungeNotebook{handler: handler}
	self329.processorMap["listTags"] = &noteStoreProcessorListTags{handler: handler}
	self329.processorMap["listTagsByNotebook"] = &noteStoreProcessorListTagsByNotebook{handler: handler}
	self329.processorMap["getTag"] = &noteStoreProcessorGetTag{handler: handler}
	self329.processorMap["createTag"] = &noteStoreProcessorCreateTag{handler: handler}
	self329.processorMap["updateTag"] = &noteStoreProcessorUpdateTag{handler: handler}
	self329.processorMap["untagAll"] = &noteStoreProcessorUntagAll{handler: handler}
	self329.processorMap["expungeTag"] = &noteStoreProcessorExpungeTag{handler: handler}
	self329.processorMap["listSearches"] = &noteStoreProcessorListSearches{handler: handler}
	self329.processorMap["getSearch"] = &noteStoreProcessorGetSearch{handler: handler}
	self329.processorMap["createSearch"] = &noteStoreProcessorCreateSearch{handler: handler}
	self329.processorMap["updateSearch"] = &noteStoreProcessorUpdateSearch{handler: handler}
	self329.processorMap["expungeSearch"] = &noteStoreProcessorExpungeSearch{handler: handler}
	self329.processorMap["findNotes"] = &noteStoreProcessorFindNotes{handler: handler}
	self329.processorMap["findNoteOffset"] = &noteStoreProcessorFindNoteOffset{handler: handler}
	self329.processorMap["findNotesMetadata"] = &noteStoreProcessorFindNotesMetadata{handler: handler}
	self329.processorMap["findNoteCounts"] = &noteStoreProcessorFindNoteCounts{handler: handler}
	self329.processorMap["getNote"] = &noteStoreProcessorGetNote{handler: handler}
	self329.processorMap["getNoteApplicationData"] = &noteStoreProcessorGetNoteApplicationData{handler: handler}
	self329.processorMap["getNoteApplicationDataEntry"] = &noteStoreProcessorGetNoteApplicationDataEntry{handler: handler}
	self329.processorMap["setNoteApplicationDataEntry"] = &noteStoreProcessorSetNoteApplicationDataEntry{handler: handler}
	self329.processorMap["unsetNoteApplicationDataEntry"] = &noteStoreProcessorUnsetNoteApplicationDataEntry{handler: handler}
	self329.processorMap["getNoteContent"] = &noteStoreProcessorGetNoteContent{handler: handler}
	self329.processorMap["getNoteSearchText"] = &noteStoreProcessorGetNoteSearchText{handler: handler}
	self329.processorMap["getResourceSearchText"] = &noteStoreProcessorGetResourceSearchText{handler: handler}
	self329.processorMap["getNoteTagNames"] = &noteStoreProcessorGetNoteTagNames{handler: handler}
	self329.processorMap["createNote"] = &noteStoreProcessorCreateNote{handler: handler}
	self329.processorMap["updateNote"] = &noteStoreProcessorUpdateNote{handler: handler}
	self329.processorMap["deleteNote"] = &noteStoreProcessorDeleteNote{handler: handler}
	self329.processorMap["expungeNote"] = &noteStoreProcessorExpungeNote{handler: handler}
	self329.processorMap["expungeNotes"] = &noteStoreProcessorExpungeNotes{handler: handler}
	self329.processorMap["expungeInactiveNotes"] = &noteStoreProcessorExpungeInactiveNotes{handler: handler}
	self329.processorMap["copyNote"] = &noteStoreProcessorCopyNote{handler: handler}
	self329.processorMap["listNoteVersions"] = &noteStoreProcessorListNoteVersions{handler: handler}
	self329.processorMap["getNoteVersion"] = &noteStoreProcessorGetNoteVersion{handler: handler}
	self329.processorMap["getResource"] = &noteStoreProcessorGetResource{handler: handler}
	self329.processorMap["getResourceApplicationData"] = &noteStoreProcessorGetResourceApplicationData{handler: handler}
	self329.processorMap["getResourceApplicationDataEntry"] = &noteStoreProcessorGetResourceApplicationDataEntry{handler: handler}
	self329.processorMap["setResourceApplicationDataEntry"] = &noteStoreProcessorSetResourceApplicationDataEntry{handler: handler}
	self329.processorMap["unsetResourceApplicationDataEntry"] = &noteStoreProcessorUnsetResourceApplicationDataEntry{handler: handler}
	self329.processorMap["updateResource"] = &noteStoreProcessorUpdateResource{handler: handler}
	self329.processorMap["getResourceData"] = &noteStoreProcessorGetResourceData{handler: handler}
	self329.processorMap["getResourceByHash"] = &noteStoreProcessorGetResourceByHash{handler: handler}
	self329.processorMap["getResourceRecognition"] = &noteStoreProcessorGetResourceRecognition{handler: handler}
	self329.processorMap["getResourceAlternateData"] = &noteStoreProcessorGetResourceAlternateData{handler: handler}
	self329.processorMap["getResourceAttributes"] = &noteStoreProcessorGetResourceAttributes{handler: handler}
	self329.processorMap["getPublicNotebook"] = &noteStoreProcessorGetPublicNotebook{handler: handler}
	self329.processorMap["createSharedNotebook"] = &noteStoreProcessorCreateSharedNotebook{handler: handler}
	self329.processorMap["updateSharedNotebook"] = &noteStoreProcessorUpdateSharedNotebook{handler: handler}
	self329.processorMap["setSharedNotebookRecipientSettings"] = &noteStoreProcessorSetSharedNotebookRecipientSettings{handler: handler}
	self329.processorMap["sendMessageToSharedNotebookMembers"] = &noteStoreProcessorSendMessageToSharedNotebookMembers{handler: handler}
	self329.processorMap["listSharedNotebooks"] = &noteStoreProcessorListSharedNotebooks{handler: handler}
	self329.processorMap["expungeSharedNotebooks"] = &noteStoreProcessorExpungeSharedNotebooks{handler: handler}
	self329.processorMap["createLinkedNotebook"] = &noteStoreProcessorCreateLinkedNotebook{handler: handler}
	self329.processorMap["updateLinkedNotebook"] = &noteStoreProcessorUpdateLinkedNotebook{handler: handler}
	self329.processorMap["listLinkedNotebooks"] = &noteStoreProcessorListLinkedNotebooks{handler: handler}
	self329.processorMap["expungeLinkedNotebook"] = &noteStoreProcessorExpungeLinkedNotebook{handler: handler}
	self329.processorMap["authenticateToSharedNotebook"] = &noteStoreProcessorAuthenticateToSharedNotebook{handler: handler}
	self329.processorMap["getSharedNotebookByAuth"] = &noteStoreProcessorGetSharedNotebookByAuth{handler: handler}
	self329.processorMap["emailNote"] = &noteStoreProcessorEmailNote{handler: handler}
	self329.processorMap["shareNote"] = &noteStoreProcessorShareNote{handler: handler}
	self329.processorMap["stopSharingNote"] = &noteStoreProcessorStopSharingNote{handler: handler}
	self329.processorMap["authenticateToSharedNote"] = &noteStoreProcessorAuthenticateToSharedNote{handler: handler}
	self329.processorMap["findRelated"] = &noteStoreProcessorFindRelated{handler: handler}
	return self329
}

func (p *NoteStoreProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin(ctx)

	if err != nil {
		x330 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
		return false, x330
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x330 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x330.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x330

}

type noteStoreProcessorGetSyncState struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetSyncState) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetSyncStateArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getSyncState", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetSyncStateResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetSyncState(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSyncState: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getSyncState", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getSyncState", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetSyncStateWithMetrics struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetSyncStateWithMetrics) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetSyncStateWithMetricsArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getSyncStateWithMetrics", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetSyncStateWithMetricsResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetSyncStateWithMetrics(ctx, args.AuthenticationToken, args.ClientMetrics); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSyncStateWithMetrics: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getSyncStateWithMetrics", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getSyncStateWithMetrics", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetSyncChunk struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetSyncChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetSyncChunkArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getSyncChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetSyncChunkResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetSyncChunk(ctx, args.AuthenticationToken, args.AfterUSN, args.MaxEntries, args.FullSyncOnly); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSyncChunk: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getSyncChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getSyncChunk", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetFilteredSyncChunk struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetFilteredSyncChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetFilteredSyncChunkArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getFilteredSyncChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetFilteredSyncChunkResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetFilteredSyncChunk(ctx, args.AuthenticationToken, args.AfterUSN, args.MaxEntries, args.Filter); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getFilteredSyncChunk: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getFilteredSyncChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getFilteredSyncChunk", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetLinkedNotebookSyncState struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetLinkedNotebookSyncState) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetLinkedNotebookSyncStateArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncState", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetLinkedNotebookSyncStateResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetLinkedNotebookSyncState(ctx, args.AuthenticationToken, args.LinkedNotebook); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getLinkedNotebookSyncState: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncState", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncState", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetLinkedNotebookSyncChunk struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetLinkedNotebookSyncChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetLinkedNotebookSyncChunkArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetLinkedNotebookSyncChunkResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetLinkedNotebookSyncChunk(ctx, args.AuthenticationToken, args.LinkedNotebook, args.AfterUSN, args.MaxEntries, args.FullSyncOnly); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getLinkedNotebookSyncChunk: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncChunk", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncChunk", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorListNotebooks struct {
	handler NoteStore
}

func (p *noteStoreProcessorListNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewListNotebooksArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "listNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewListNotebooksResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.ListNotebooks(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNotebooks: "+err.Error())
		oprot.WriteMessageBegin(ctx, "listNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "listNotebooks", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNotebookResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNotebook(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetDefaultNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetDefaultNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetDefaultNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getDefaultNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetDefaultNotebookResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetDefaultNotebook(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getDefaultNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getDefaultNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getDefaultNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorCreateNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorCreateNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewCreateNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "createNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewCreateNotebookResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.CreateNotebook(ctx, args.AuthenticationToken, args.Notebook); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "createNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "createNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUpdateNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorUpdateNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUpdateNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "updateNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUpdateNotebookResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UpdateNotebook(ctx, args.AuthenticationToken, args.Notebook); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "updateNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "updateNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeNotebookResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.ExpungeNotebook(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorListTags struct {
	handler NoteStore
}

func (p *noteStoreProcessorListTags) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewListTagsArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "listTags", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewListTagsResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.ListTags(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listTags: "+err.Error())
		oprot.WriteMessageBegin(ctx, "listTags", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "listTags", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorListTagsByNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorListTagsByNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewListTagsByNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "listTagsByNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewListTagsByNotebookResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.ListTagsByNotebook(ctx, args.AuthenticationToken, args.NotebookGuid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listTagsByNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "listTagsByNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "listTagsByNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetTag struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetTagArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetTagResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetTag(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTag: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getTag", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorCreateTag struct {
	handler NoteStore
}

func (p *noteStoreProcessorCreateTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewCreateTagArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "createTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewCreateTagResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.CreateTag(ctx, args.AuthenticationToken, args.Tag); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTag: "+err.Error())
		oprot.WriteMessageBegin(ctx, "createTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "createTag", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUpdateTag struct {
	handler NoteStore
}

func (p *noteStoreProcessorUpdateTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUpdateTagArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "updateTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUpdateTagResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UpdateTag(ctx, args.AuthenticationToken, args.Tag); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateTag: "+err.Error())
		oprot.WriteMessageBegin(ctx, "updateTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "updateTag", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUntagAll struct {
	handler NoteStore
}

func (p *noteStoreProcessorUntagAll) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUntagAllArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "untagAll", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUntagAllResult()
	var err error
	if result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UntagAll(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing untagAll: "+err.Error())
		oprot.WriteMessageBegin(ctx, "untagAll", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "untagAll", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeTag struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeTagArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeTagResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.ExpungeTag(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeTag: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeTag", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeTag", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorListSearches struct {
	handler NoteStore
}

func (p *noteStoreProcessorListSearches) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewListSearchesArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "listSearches", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewListSearchesResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.ListSearches(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listSearches: "+err.Error())
		oprot.WriteMessageBegin(ctx, "listSearches", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "listSearches", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetSearch struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetSearchArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetSearchResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetSearch(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSearch: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getSearch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorCreateSearch struct {
	handler NoteStore
}

func (p *noteStoreProcessorCreateSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewCreateSearchArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "createSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewCreateSearchResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.CreateSearch(ctx, args.AuthenticationToken, args.Search); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createSearch: "+err.Error())
		oprot.WriteMessageBegin(ctx, "createSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "createSearch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUpdateSearch struct {
	handler NoteStore
}

func (p *noteStoreProcessorUpdateSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUpdateSearchArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "updateSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUpdateSearchResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UpdateSearch(ctx, args.AuthenticationToken, args.Search); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateSearch: "+err.Error())
		oprot.WriteMessageBegin(ctx, "updateSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "updateSearch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeSearch struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeSearchArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeSearchResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.ExpungeSearch(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeSearch: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeSearch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeSearch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorFindNotes struct {
	handler NoteStore
}

func (p *noteStoreProcessorFindNotes) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewFindNotesArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "findNotes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewFindNotesResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.FindNotes(ctx, args.AuthenticationToken, args.Filter, args.Offset, args.MaxNotes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNotes: "+err.Error())
		oprot.WriteMessageBegin(ctx, "findNotes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "findNotes", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorFindNoteOffset struct {
	handler NoteStore
}

func (p *noteStoreProcessorFindNoteOffset) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewFindNoteOffsetArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "findNoteOffset", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewFindNoteOffsetResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.FindNoteOffset(ctx, args.AuthenticationToken, args.Filter, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNoteOffset: "+err.Error())
		oprot.WriteMessageBegin(ctx, "findNoteOffset", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "findNoteOffset", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorFindNotesMetadata struct {
	handler NoteStore
}

func (p *noteStoreProcessorFindNotesMetadata) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewFindNotesMetadataArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "findNotesMetadata", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewFindNotesMetadataResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.FindNotesMetadata(ctx, args.AuthenticationToken, args.Filter, args.Offset, args.MaxNotes, args.ResultSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNotesMetadata: "+err.Error())
		oprot.WriteMessageBegin(ctx, "findNotesMetadata", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "findNotesMetadata", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorFindNoteCounts struct {
	handler NoteStore
}

func (p *noteStoreProcessorFindNoteCounts) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewFindNoteCountsArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "findNoteCounts", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewFindNoteCountsResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.FindNoteCounts(ctx, args.AuthenticationToken, args.Filter, args.WithTrash); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNoteCounts: "+err.Error())
		oprot.WriteMessageBegin(ctx, "findNoteCounts", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "findNoteCounts", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNoteResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNote(ctx, args.AuthenticationToken, args.Guid, args.WithContent, args.WithResourcesData, args.WithResourcesRecognition, args.WithResourcesAlternateData); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNoteApplicationData struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNoteApplicationData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNoteApplicationDataArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteApplicationData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNoteApplicationDataResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNoteApplicationData(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteApplicationData: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteApplicationData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNoteApplicationData", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNoteApplicationDataEntry struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNoteApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNoteApplicationDataEntryArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNoteApplicationDataEntryResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNoteApplicationDataEntry(ctx, args.AuthenticationToken, args.Guid, args.Key); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteApplicationDataEntry: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNoteApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorSetNoteApplicationDataEntry struct {
	handler NoteStore
}

func (p *noteStoreProcessorSetNoteApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewSetNoteApplicationDataEntryArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "setNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewSetNoteApplicationDataEntryResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.SetNoteApplicationDataEntry(ctx, args.AuthenticationToken, args.Guid, args.Key, args.Value); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setNoteApplicationDataEntry: "+err.Error())
		oprot.WriteMessageBegin(ctx, "setNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "setNoteApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUnsetNoteApplicationDataEntry struct {
	handler NoteStore
}

func (p *noteStoreProcessorUnsetNoteApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUnsetNoteApplicationDataEntryArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "unsetNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUnsetNoteApplicationDataEntryResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UnsetNoteApplicationDataEntry(ctx, args.AuthenticationToken, args.Guid, args.Key); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unsetNoteApplicationDataEntry: "+err.Error())
		oprot.WriteMessageBegin(ctx, "unsetNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "unsetNoteApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNoteContent struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNoteContent) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNoteContentArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteContent", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNoteContentResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNoteContent(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteContent: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteContent", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNoteContent", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNoteSearchText struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNoteSearchText) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNoteSearchTextArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteSearchText", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNoteSearchTextResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNoteSearchText(ctx, args.AuthenticationToken, args.Guid, args.NoteOnly, args.TokenizeForIndexing); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteSearchText: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteSearchText", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNoteSearchText", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceSearchText struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceSearchText) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceSearchTextArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceSearchText", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceSearchTextResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceSearchText(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceSearchText: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceSearchText", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceSearchText", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNoteTagNames struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNoteTagNames) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNoteTagNamesArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteTagNames", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNoteTagNamesResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNoteTagNames(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteTagNames: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteTagNames", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNoteTagNames", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorCreateNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorCreateNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewCreateNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "createNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewCreateNoteResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.CreateNote(ctx, args.AuthenticationToken, args.Note); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "createNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "createNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUpdateNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorUpdateNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUpdateNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "updateNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUpdateNoteResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UpdateNote(ctx, args.AuthenticationToken, args.Note); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "updateNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "updateNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorDeleteNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorDeleteNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewDeleteNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "deleteNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewDeleteNoteResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.DeleteNote(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "deleteNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "deleteNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeNoteResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.ExpungeNote(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeNotes struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeNotes) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeNotesArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeNotes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeNotesResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.ExpungeNotes(ctx, args.AuthenticationToken, args.NoteGuids); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeNotes: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeNotes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeNotes", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeInactiveNotes struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeInactiveNotes) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeInactiveNotesArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeInactiveNotes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeInactiveNotesResult()
	var err error
	if result.Success, result.UserException, result.SystemException, err = p.handler.ExpungeInactiveNotes(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeInactiveNotes: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeInactiveNotes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeInactiveNotes", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorCopyNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorCopyNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewCopyNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "copyNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewCopyNoteResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.CopyNote(ctx, args.AuthenticationToken, args.NoteGuid, args.ToNotebookGuid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing copyNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "copyNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "copyNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorListNoteVersions struct {
	handler NoteStore
}

func (p *noteStoreProcessorListNoteVersions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewListNoteVersionsArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "listNoteVersions", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewListNoteVersionsResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.ListNoteVersions(ctx, args.AuthenticationToken, args.NoteGuid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNoteVersions: "+err.Error())
		oprot.WriteMessageBegin(ctx, "listNoteVersions", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "listNoteVersions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetNoteVersion struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetNoteVersion) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetNoteVersionArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteVersion", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetNoteVersionResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetNoteVersion(ctx, args.AuthenticationToken, args.NoteGuid, args.UpdateSequenceNum, args.WithResourcesData, args.WithResourcesRecognition, args.WithResourcesAlternateData); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteVersion: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getNoteVersion", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getNoteVersion", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResource struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResource) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResource", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResource(ctx, args.AuthenticationToken, args.Guid, args.WithData, args.WithRecognition, args.WithAttributes, args.WithAlternateData); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResource: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResource", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResource", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceApplicationData struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceApplicationData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceApplicationDataArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceApplicationData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceApplicationDataResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceApplicationData(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceApplicationData: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceApplicationData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceApplicationData", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceApplicationDataEntry struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceApplicationDataEntryArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceApplicationDataEntryResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceApplicationDataEntry(ctx, args.AuthenticationToken, args.Guid, args.Key); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceApplicationDataEntry: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorSetResourceApplicationDataEntry struct {
	handler NoteStore
}

func (p *noteStoreProcessorSetResourceApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewSetResourceApplicationDataEntryArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "setResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewSetResourceApplicationDataEntryResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.SetResourceApplicationDataEntry(ctx, args.AuthenticationToken, args.Guid, args.Key, args.Value); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setResourceApplicationDataEntry: "+err.Error())
		oprot.WriteMessageBegin(ctx, "setResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "setResourceApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUnsetResourceApplicationDataEntry struct {
	handler NoteStore
}

func (p *noteStoreProcessorUnsetResourceApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUnsetResourceApplicationDataEntryArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "unsetResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUnsetResourceApplicationDataEntryResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UnsetResourceApplicationDataEntry(ctx, args.AuthenticationToken, args.Guid, args.Key); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unsetResourceApplicationDataEntry: "+err.Error())
		oprot.WriteMessageBegin(ctx, "unsetResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "unsetResourceApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUpdateResource struct {
	handler NoteStore
}

func (p *noteStoreProcessorUpdateResource) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUpdateResourceArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "updateResource", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUpdateResourceResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UpdateResource(ctx, args.AuthenticationToken, args.Resource); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateResource: "+err.Error())
		oprot.WriteMessageBegin(ctx, "updateResource", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "updateResource", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceData struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceDataArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceDataResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceData(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceData: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceData", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceByHash struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceByHash) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceByHashArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceByHash", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceByHashResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceByHash(ctx, args.AuthenticationToken, args.NoteGuid, args.ContentHash, args.WithData, args.WithRecognition, args.WithAlternateData); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceByHash: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceByHash", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceByHash", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceRecognition struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceRecognition) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceRecognitionArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceRecognition", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceRecognitionResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceRecognition(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceRecognition: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceRecognition", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceRecognition", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceAlternateData struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceAlternateData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceAlternateDataArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceAlternateData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceAlternateDataResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceAlternateData(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceAlternateData: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceAlternateData", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceAlternateData", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetResourceAttributes struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetResourceAttributes) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetResourceAttributesArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceAttributes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetResourceAttributesResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.GetResourceAttributes(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceAttributes: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getResourceAttributes", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getResourceAttributes", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetPublicNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetPublicNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetPublicNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getPublicNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetPublicNotebookResult()
	var err error
	if result.Success, result.SystemException, result.NotFoundException, err = p.handler.GetPublicNotebook(ctx, args.UserId, args.PublicUri); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPublicNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getPublicNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getPublicNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorCreateSharedNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorCreateSharedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewCreateSharedNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "createSharedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewCreateSharedNotebookResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.CreateSharedNotebook(ctx, args.AuthenticationToken, args.SharedNotebook); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createSharedNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "createSharedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "createSharedNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUpdateSharedNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorUpdateSharedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUpdateSharedNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "updateSharedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUpdateSharedNotebookResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.UpdateSharedNotebook(ctx, args.AuthenticationToken, args.SharedNotebook); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateSharedNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "updateSharedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "updateSharedNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorSetSharedNotebookRecipientSettings struct {
	handler NoteStore
}

func (p *noteStoreProcessorSetSharedNotebookRecipientSettings) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewSetSharedNotebookRecipientSettingsArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "setSharedNotebookRecipientSettings", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewSetSharedNotebookRecipientSettingsResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.SetSharedNotebookRecipientSettings(ctx, args.AuthenticationToken, args.SharedNotebookId, args.RecipientSettings); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setSharedNotebookRecipientSettings: "+err.Error())
		oprot.WriteMessageBegin(ctx, "setSharedNotebookRecipientSettings", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "setSharedNotebookRecipientSettings", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorSendMessageToSharedNotebookMembers struct {
	handler NoteStore
}

func (p *noteStoreProcessorSendMessageToSharedNotebookMembers) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewSendMessageToSharedNotebookMembersArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "sendMessageToSharedNotebookMembers", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewSendMessageToSharedNotebookMembersResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.SendMessageToSharedNotebookMembers(ctx, args.AuthenticationToken, args.NotebookGuid, args.MessageText, args.Recipients); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sendMessageToSharedNotebookMembers: "+err.Error())
		oprot.WriteMessageBegin(ctx, "sendMessageToSharedNotebookMembers", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "sendMessageToSharedNotebookMembers", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorListSharedNotebooks struct {
	handler NoteStore
}

func (p *noteStoreProcessorListSharedNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewListSharedNotebooksArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "listSharedNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewListSharedNotebooksResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.ListSharedNotebooks(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listSharedNotebooks: "+err.Error())
		oprot.WriteMessageBegin(ctx, "listSharedNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "listSharedNotebooks", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeSharedNotebooks struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeSharedNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeSharedNotebooksArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeSharedNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeSharedNotebooksResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.ExpungeSharedNotebooks(ctx, args.AuthenticationToken, args.SharedNotebookIds); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeSharedNotebooks: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeSharedNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeSharedNotebooks", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorCreateLinkedNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorCreateLinkedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewCreateLinkedNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "createLinkedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewCreateLinkedNotebookResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.CreateLinkedNotebook(ctx, args.AuthenticationToken, args.LinkedNotebook); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createLinkedNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "createLinkedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "createLinkedNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorUpdateLinkedNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorUpdateLinkedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewUpdateLinkedNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "updateLinkedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewUpdateLinkedNotebookResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.UpdateLinkedNotebook(ctx, args.AuthenticationToken, args.LinkedNotebook); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateLinkedNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "updateLinkedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "updateLinkedNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorListLinkedNotebooks struct {
	handler NoteStore
}

func (p *noteStoreProcessorListLinkedNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewListLinkedNotebooksArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "listLinkedNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewListLinkedNotebooksResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.ListLinkedNotebooks(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listLinkedNotebooks: "+err.Error())
		oprot.WriteMessageBegin(ctx, "listLinkedNotebooks", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "listLinkedNotebooks", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorExpungeLinkedNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorExpungeLinkedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewExpungeLinkedNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "expungeLinkedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewExpungeLinkedNotebookResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.ExpungeLinkedNotebook(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeLinkedNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "expungeLinkedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "expungeLinkedNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorAuthenticateToSharedNotebook struct {
	handler NoteStore
}

func (p *noteStoreProcessorAuthenticateToSharedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewAuthenticateToSharedNotebookArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "authenticateToSharedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewAuthenticateToSharedNotebookResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.AuthenticateToSharedNotebook(ctx, args.ShareKey, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToSharedNotebook: "+err.Error())
		oprot.WriteMessageBegin(ctx, "authenticateToSharedNotebook", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "authenticateToSharedNotebook", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorGetSharedNotebookByAuth struct {
	handler NoteStore
}

func (p *noteStoreProcessorGetSharedNotebookByAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewGetSharedNotebookByAuthArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "getSharedNotebookByAuth", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewGetSharedNotebookByAuthResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.GetSharedNotebookByAuth(ctx, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSharedNotebookByAuth: "+err.Error())
		oprot.WriteMessageBegin(ctx, "getSharedNotebookByAuth", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "getSharedNotebookByAuth", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorEmailNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorEmailNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewEmailNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "emailNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewEmailNoteResult()
	var err error
	if result.UserException, result.NotFoundException, result.SystemException, err = p.handler.EmailNote(ctx, args.AuthenticationToken, args.Parameters); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing emailNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "emailNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "emailNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorShareNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorShareNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewShareNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "shareNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewShareNoteResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.ShareNote(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shareNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "shareNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "shareNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorStopSharingNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorStopSharingNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewStopSharingNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "stopSharingNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewStopSharingNoteResult()
	var err error
	if result.UserException, result.NotFoundException, result.SystemException, err = p.handler.StopSharingNote(ctx, args.AuthenticationToken, args.Guid); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing stopSharingNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "stopSharingNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "stopSharingNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorAuthenticateToSharedNote struct {
	handler NoteStore
}

func (p *noteStoreProcessorAuthenticateToSharedNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewAuthenticateToSharedNoteArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "authenticateToSharedNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewAuthenticateToSharedNoteResult()
	var err error
	if result.Success, result.UserException, result.NotFoundException, result.SystemException, err = p.handler.AuthenticateToSharedNote(ctx, args.Guid, args.NoteKey, args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToSharedNote: "+err.Error())
		oprot.WriteMessageBegin(ctx, "authenticateToSharedNote", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "authenticateToSharedNote", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

type noteStoreProcessorFindRelated struct {
	handler NoteStore
}

func (p *noteStoreProcessorFindRelated) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, exp thrift.TException) {
	args := NewFindRelatedArgs()
	if err := args.Read(ctx, iprot); err != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin(ctx, "findRelated", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	iprot.ReadMessageEnd(ctx)
	result := NewFindRelatedResult()
	var err error
	if result.Success, result.UserException, result.SystemException, result.NotFoundException, err = p.handler.FindRelated(ctx, args.AuthenticationToken, args.Query, args.ResultSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findRelated: "+err.Error())
		oprot.WriteMessageBegin(ctx, "findRelated", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return
	}
	if err2 := oprot.WriteMessageBegin(ctx, "findRelated", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(ctx, oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, nil
}

// HELPER FUNCTIONS AND STRUCTURES

type GetSyncStateArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetSyncStateArgs() *GetSyncStateArgs {
	return &GetSyncStateArgs{}
}

func (p *GetSyncStateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSyncStateArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetSyncStateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSyncState_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSyncStateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetSyncStateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSyncStateArgs(%+v)", *p)
}

type GetSyncStateResult struct {
	Success         *SyncState                  `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetSyncStateResult() *GetSyncStateResult {
	return &GetSyncStateResult{}
}

func (p *GetSyncStateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSyncStateResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewSyncState()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetSyncStateResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetSyncStateResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetSyncStateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSyncState_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSyncStateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncStateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncStateResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncStateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSyncStateResult(%+v)", *p)
}

type GetSyncStateWithMetricsArgs struct {
	AuthenticationToken string              `thrift:"authenticationToken,1"`
	ClientMetrics       *ClientUsageMetrics `thrift:"clientMetrics,2"`
}

func NewGetSyncStateWithMetricsArgs() *GetSyncStateWithMetricsArgs {
	return &GetSyncStateWithMetricsArgs{}
}

func (p *GetSyncStateWithMetricsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSyncStateWithMetricsArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetSyncStateWithMetricsArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.ClientMetrics = NewClientUsageMetrics()
	if err := p.ClientMetrics.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ClientMetrics)
	}
	return nil
}

func (p *GetSyncStateWithMetricsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSyncStateWithMetrics_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSyncStateWithMetricsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetSyncStateWithMetricsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.ClientMetrics != nil {
		if err := oprot.WriteFieldBegin(ctx, "clientMetrics", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:clientMetrics: %s", p, err)
		}
		if err := p.ClientMetrics.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ClientMetrics)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:clientMetrics: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncStateWithMetricsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSyncStateWithMetricsArgs(%+v)", *p)
}

type GetSyncStateWithMetricsResult struct {
	Success         *SyncState                  `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetSyncStateWithMetricsResult() *GetSyncStateWithMetricsResult {
	return &GetSyncStateWithMetricsResult{}
}

func (p *GetSyncStateWithMetricsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSyncStateWithMetricsResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewSyncState()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetSyncStateWithMetricsResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetSyncStateWithMetricsResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetSyncStateWithMetricsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSyncStateWithMetrics_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSyncStateWithMetricsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncStateWithMetricsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncStateWithMetricsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncStateWithMetricsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSyncStateWithMetricsResult(%+v)", *p)
}

type GetSyncChunkArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
	AfterUSN            int32  `thrift:"afterUSN,2"`
	MaxEntries          int32  `thrift:"maxEntries,3"`
	FullSyncOnly        bool   `thrift:"fullSyncOnly,4"`
}

func NewGetSyncChunkArgs() *GetSyncChunkArgs {
	return &GetSyncChunkArgs{}
}

func (p *GetSyncChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSyncChunkArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetSyncChunkArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.AfterUSN = v
	}
	return nil
}

func (p *GetSyncChunkArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.MaxEntries = v
	}
	return nil
}

func (p *GetSyncChunkArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.FullSyncOnly = v
	}
	return nil
}

func (p *GetSyncChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSyncChunk_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSyncChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetSyncChunkArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "afterUSN", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:afterUSN: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.AfterUSN)); err != nil {
		return fmt.Errorf("%T.afterUSN (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:afterUSN: %s", p, err)
	}
	return err
}

func (p *GetSyncChunkArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "maxEntries", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:maxEntries: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.MaxEntries)); err != nil {
		return fmt.Errorf("%T.maxEntries (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:maxEntries: %s", p, err)
	}
	return err
}

func (p *GetSyncChunkArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "fullSyncOnly", thrift.BOOL, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:fullSyncOnly: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.FullSyncOnly)); err != nil {
		return fmt.Errorf("%T.fullSyncOnly (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:fullSyncOnly: %s", p, err)
	}
	return err
}

func (p *GetSyncChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSyncChunkArgs(%+v)", *p)
}

type GetSyncChunkResult struct {
	Success         *SyncChunk                  `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetSyncChunkResult() *GetSyncChunkResult {
	return &GetSyncChunkResult{}
}

func (p *GetSyncChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSyncChunkResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewSyncChunk()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetSyncChunkResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetSyncChunkResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetSyncChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSyncChunk_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSyncChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncChunkResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetSyncChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSyncChunkResult(%+v)", *p)
}

type GetFilteredSyncChunkArgs struct {
	AuthenticationToken string           `thrift:"authenticationToken,1"`
	AfterUSN            int32            `thrift:"afterUSN,2"`
	MaxEntries          int32            `thrift:"maxEntries,3"`
	Filter              *SyncChunkFilter `thrift:"filter,4"`
}

func NewGetFilteredSyncChunkArgs() *GetFilteredSyncChunkArgs {
	return &GetFilteredSyncChunkArgs{}
}

func (p *GetFilteredSyncChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFilteredSyncChunkArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetFilteredSyncChunkArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.AfterUSN = v
	}
	return nil
}

func (p *GetFilteredSyncChunkArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.MaxEntries = v
	}
	return nil
}

func (p *GetFilteredSyncChunkArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.Filter = NewSyncChunkFilter()
	if err := p.Filter.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Filter)
	}
	return nil
}

func (p *GetFilteredSyncChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getFilteredSyncChunk_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFilteredSyncChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetFilteredSyncChunkArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "afterUSN", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:afterUSN: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.AfterUSN)); err != nil {
		return fmt.Errorf("%T.afterUSN (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:afterUSN: %s", p, err)
	}
	return err
}

func (p *GetFilteredSyncChunkArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "maxEntries", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:maxEntries: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.MaxEntries)); err != nil {
		return fmt.Errorf("%T.maxEntries (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:maxEntries: %s", p, err)
	}
	return err
}

func (p *GetFilteredSyncChunkArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Filter != nil {
		if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:filter: %s", p, err)
		}
		if err := p.Filter.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Filter)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 4:filter: %s", p, err)
		}
	}
	return err
}

func (p *GetFilteredSyncChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFilteredSyncChunkArgs(%+v)", *p)
}

type GetFilteredSyncChunkResult struct {
	Success         *SyncChunk                  `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetFilteredSyncChunkResult() *GetFilteredSyncChunkResult {
	return &GetFilteredSyncChunkResult{}
}

func (p *GetFilteredSyncChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFilteredSyncChunkResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewSyncChunk()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetFilteredSyncChunkResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetFilteredSyncChunkResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetFilteredSyncChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getFilteredSyncChunk_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFilteredSyncChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetFilteredSyncChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetFilteredSyncChunkResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetFilteredSyncChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFilteredSyncChunkResult(%+v)", *p)
}

type GetLinkedNotebookSyncStateArgs struct {
	AuthenticationToken string                `thrift:"authenticationToken,1"`
	LinkedNotebook      *Types.LinkedNotebook `thrift:"linkedNotebook,2"`
}

func NewGetLinkedNotebookSyncStateArgs() *GetLinkedNotebookSyncStateArgs {
	return &GetLinkedNotebookSyncStateArgs{}
}

func (p *GetLinkedNotebookSyncStateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.LinkedNotebook = Types.NewLinkedNotebook()
	if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LinkedNotebook)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncState_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetLinkedNotebookSyncStateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.LinkedNotebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:linkedNotebook: %s", p, err)
		}
		if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.LinkedNotebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:linkedNotebook: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncStateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLinkedNotebookSyncStateArgs(%+v)", *p)
}

type GetLinkedNotebookSyncStateResult struct {
	Success           *SyncState                    `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetLinkedNotebookSyncStateResult() *GetLinkedNotebookSyncStateResult {
	return &GetLinkedNotebookSyncStateResult{}
}

func (p *GetLinkedNotebookSyncStateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewSyncState()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncState_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncStateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncStateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncStateResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncStateResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncStateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLinkedNotebookSyncStateResult(%+v)", *p)
}

type GetLinkedNotebookSyncChunkArgs struct {
	AuthenticationToken string                `thrift:"authenticationToken,1"`
	LinkedNotebook      *Types.LinkedNotebook `thrift:"linkedNotebook,2"`
	AfterUSN            int32                 `thrift:"afterUSN,3"`
	MaxEntries          int32                 `thrift:"maxEntries,4"`
	FullSyncOnly        bool                  `thrift:"fullSyncOnly,5"`
}

func NewGetLinkedNotebookSyncChunkArgs() *GetLinkedNotebookSyncChunkArgs {
	return &GetLinkedNotebookSyncChunkArgs{}
}

func (p *GetLinkedNotebookSyncChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.LinkedNotebook = Types.NewLinkedNotebook()
	if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LinkedNotebook)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.AfterUSN = v
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.MaxEntries = v
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkArgs) readField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.FullSyncOnly = v
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncChunk_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField5(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.LinkedNotebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:linkedNotebook: %s", p, err)
		}
		if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.LinkedNotebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:linkedNotebook: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "afterUSN", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:afterUSN: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.AfterUSN)); err != nil {
		return fmt.Errorf("%T.afterUSN (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:afterUSN: %s", p, err)
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "maxEntries", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:maxEntries: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.MaxEntries)); err != nil {
		return fmt.Errorf("%T.maxEntries (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:maxEntries: %s", p, err)
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "fullSyncOnly", thrift.BOOL, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:fullSyncOnly: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.FullSyncOnly)); err != nil {
		return fmt.Errorf("%T.fullSyncOnly (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 5:fullSyncOnly: %s", p, err)
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLinkedNotebookSyncChunkArgs(%+v)", *p)
}

type GetLinkedNotebookSyncChunkResult struct {
	Success           *SyncChunk                    `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetLinkedNotebookSyncChunkResult() *GetLinkedNotebookSyncChunkResult {
	return &GetLinkedNotebookSyncChunkResult{}
}

func (p *GetLinkedNotebookSyncChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewSyncChunk()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncChunk_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLinkedNotebookSyncChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetLinkedNotebookSyncChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLinkedNotebookSyncChunkResult(%+v)", *p)
}

type ListNotebooksArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewListNotebooksArgs() *ListNotebooksArgs {
	return &ListNotebooksArgs{}
}

func (p *ListNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNotebooksArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listNotebooks_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListNotebooksArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNotebooksArgs(%+v)", *p)
}

type ListNotebooksResult struct {
	Success         []*Types.Notebook           `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewListNotebooksResult() *ListNotebooksResult {
	return &ListNotebooksResult{}
}

func (p *ListNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNotebooksResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Types.Notebook, 0, size)
	for i := 0; i < size; i++ {
		_elem331 := Types.NewNotebook()
		if err := _elem331.Read(ctx, iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem331)
		}
		p.Success = append(p.Success, _elem331)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListNotebooksResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListNotebooksResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listNotebooks_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListNotebooksResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNotebooksResult(%+v)", *p)
}

type GetNotebookArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetNotebookArgs() *GetNotebookArgs {
	return &GetNotebookArgs{}
}

func (p *GetNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNotebookArgs(%+v)", *p)
}

type GetNotebookResult struct {
	Success           *Types.Notebook               `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNotebookResult() *GetNotebookResult {
	return &GetNotebookResult{}
}

func (p *GetNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNotebook()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNotebookResult(%+v)", *p)
}

type GetDefaultNotebookArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetDefaultNotebookArgs() *GetDefaultNotebookArgs {
	return &GetDefaultNotebookArgs{}
}

func (p *GetDefaultNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDefaultNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetDefaultNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getDefaultNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDefaultNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetDefaultNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDefaultNotebookArgs(%+v)", *p)
}

type GetDefaultNotebookResult struct {
	Success         *Types.Notebook             `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetDefaultNotebookResult() *GetDefaultNotebookResult {
	return &GetDefaultNotebookResult{}
}

func (p *GetDefaultNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDefaultNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNotebook()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetDefaultNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetDefaultNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetDefaultNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getDefaultNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDefaultNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetDefaultNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetDefaultNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetDefaultNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDefaultNotebookResult(%+v)", *p)
}

type CreateNotebookArgs struct {
	AuthenticationToken string          `thrift:"authenticationToken,1"`
	Notebook            *Types.Notebook `thrift:"notebook,2"`
}

func NewCreateNotebookArgs() *CreateNotebookArgs {
	return &CreateNotebookArgs{}
}

func (p *CreateNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CreateNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Notebook = Types.NewNotebook()
	if err := p.Notebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Notebook)
	}
	return nil
}

func (p *CreateNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CreateNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Notebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "notebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notebook: %s", p, err)
		}
		if err := p.Notebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Notebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notebook: %s", p, err)
		}
	}
	return err
}

func (p *CreateNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNotebookArgs(%+v)", *p)
}

type CreateNotebookResult struct {
	Success         *Types.Notebook             `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewCreateNotebookResult() *CreateNotebookResult {
	return &CreateNotebookResult{}
}

func (p *CreateNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNotebook()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CreateNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CreateNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CreateNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CreateNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CreateNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNotebookResult(%+v)", *p)
}

type UpdateNotebookArgs struct {
	AuthenticationToken string          `thrift:"authenticationToken,1"`
	Notebook            *Types.Notebook `thrift:"notebook,2"`
}

func NewUpdateNotebookArgs() *UpdateNotebookArgs {
	return &UpdateNotebookArgs{}
}

func (p *UpdateNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Notebook = Types.NewNotebook()
	if err := p.Notebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Notebook)
	}
	return nil
}

func (p *UpdateNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Notebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "notebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notebook: %s", p, err)
		}
		if err := p.Notebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Notebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notebook: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateNotebookArgs(%+v)", *p)
}

type UpdateNotebookResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUpdateNotebookResult() *UpdateNotebookResult {
	return &UpdateNotebookResult{}
}

func (p *UpdateNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UpdateNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UpdateNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateNotebookResult(%+v)", *p)
}

type ExpungeNotebookArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewExpungeNotebookArgs() *ExpungeNotebookArgs {
	return &ExpungeNotebookArgs{}
}

func (p *ExpungeNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *ExpungeNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *ExpungeNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeNotebookArgs(%+v)", *p)
}

type ExpungeNotebookResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewExpungeNotebookResult() *ExpungeNotebookResult {
	return &ExpungeNotebookResult{}
}

func (p *ExpungeNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ExpungeNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeNotebookResult(%+v)", *p)
}

type ListTagsArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewListTagsArgs() *ListTagsArgs {
	return &ListTagsArgs{}
}

func (p *ListTagsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListTagsArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListTagsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listTags_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListTagsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListTagsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListTagsArgs(%+v)", *p)
}

type ListTagsResult struct {
	Success         []*Types.Tag                `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewListTagsResult() *ListTagsResult {
	return &ListTagsResult{}
}

func (p *ListTagsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListTagsResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Types.Tag, 0, size)
	for i := 0; i < size; i++ {
		_elem332 := Types.NewTag()
		if err := _elem332.Read(ctx, iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem332)
		}
		p.Success = append(p.Success, _elem332)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListTagsResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListTagsResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListTagsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listTags_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListTagsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListTagsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListTagsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListTagsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListTagsResult(%+v)", *p)
}

type ListTagsByNotebookArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	NotebookGuid        Types.Guid `thrift:"notebookGuid,2"`
}

func NewListTagsByNotebookArgs() *ListTagsByNotebookArgs {
	return &ListTagsByNotebookArgs{}
}

func (p *ListTagsByNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListTagsByNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListTagsByNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NotebookGuid = Types.Guid(v)
	}
	return nil
}

func (p *ListTagsByNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listTagsByNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListTagsByNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListTagsByNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:notebookGuid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.NotebookGuid)); err != nil {
		return fmt.Errorf("%T.notebookGuid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:notebookGuid: %s", p, err)
	}
	return err
}

func (p *ListTagsByNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListTagsByNotebookArgs(%+v)", *p)
}

type ListTagsByNotebookResult struct {
	Success           []*Types.Tag                  `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewListTagsByNotebookResult() *ListTagsByNotebookResult {
	return &ListTagsByNotebookResult{}
}

func (p *ListTagsByNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListTagsByNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Types.Tag, 0, size)
	for i := 0; i < size; i++ {
		_elem333 := Types.NewTag()
		if err := _elem333.Read(ctx, iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem333)
		}
		p.Success = append(p.Success, _elem333)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListTagsByNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListTagsByNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListTagsByNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ListTagsByNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listTagsByNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListTagsByNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListTagsByNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListTagsByNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListTagsByNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ListTagsByNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListTagsByNotebookResult(%+v)", *p)
}

type GetTagArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetTagArgs() *GetTagArgs {
	return &GetTagArgs{}
}

func (p *GetTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTagArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetTagArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTag_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetTagArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTagArgs(%+v)", *p)
}

type GetTagResult struct {
	Success           *Types.Tag                    `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetTagResult() *GetTagResult {
	return &GetTagResult{}
}

func (p *GetTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTagResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewTag()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetTagResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetTagResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetTagResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getTag_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetTagResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTagResult(%+v)", *p)
}

type CreateTagArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Tag                 *Types.Tag `thrift:"tag,2"`
}

func NewCreateTagArgs() *CreateTagArgs {
	return &CreateTagArgs{}
}

func (p *CreateTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTagArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CreateTagArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tag = Types.NewTag()
	if err := p.Tag.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tag)
	}
	return nil
}

func (p *CreateTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createTag_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CreateTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Tag != nil {
		if err := oprot.WriteFieldBegin(ctx, "tag", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:tag: %s", p, err)
		}
		if err := p.Tag.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Tag)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:tag: %s", p, err)
		}
	}
	return err
}

func (p *CreateTagArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTagArgs(%+v)", *p)
}

type CreateTagResult struct {
	Success           *Types.Tag                    `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewCreateTagResult() *CreateTagResult {
	return &CreateTagResult{}
}

func (p *CreateTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTagResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewTag()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CreateTagResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CreateTagResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CreateTagResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *CreateTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createTag_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CreateTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CreateTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *CreateTagResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTagResult(%+v)", *p)
}

type UpdateTagArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Tag                 *Types.Tag `thrift:"tag,2"`
}

func NewUpdateTagArgs() *UpdateTagArgs {
	return &UpdateTagArgs{}
}

func (p *UpdateTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateTagArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateTagArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Tag = Types.NewTag()
	if err := p.Tag.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tag)
	}
	return nil
}

func (p *UpdateTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateTag_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Tag != nil {
		if err := oprot.WriteFieldBegin(ctx, "tag", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:tag: %s", p, err)
		}
		if err := p.Tag.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Tag)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:tag: %s", p, err)
		}
	}
	return err
}

func (p *UpdateTagArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateTagArgs(%+v)", *p)
}

type UpdateTagResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUpdateTagResult() *UpdateTagResult {
	return &UpdateTagResult{}
}

func (p *UpdateTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateTagResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UpdateTagResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateTagResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateTagResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateTag_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UpdateTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateTagResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateTagResult(%+v)", *p)
}

type UntagAllArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewUntagAllArgs() *UntagAllArgs {
	return &UntagAllArgs{}
}

func (p *UntagAllArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UntagAllArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UntagAllArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *UntagAllArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "untagAll_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UntagAllArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UntagAllArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *UntagAllArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UntagAllArgs(%+v)", *p)
}

type UntagAllResult struct {
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUntagAllResult() *UntagAllResult {
	return &UntagAllResult{}
}

func (p *UntagAllResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UntagAllResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UntagAllResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UntagAllResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UntagAllResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "untagAll_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UntagAllResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UntagAllResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UntagAllResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UntagAllResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UntagAllResult(%+v)", *p)
}

type ExpungeTagArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewExpungeTagArgs() *ExpungeTagArgs {
	return &ExpungeTagArgs{}
}

func (p *ExpungeTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeTagArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeTagArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *ExpungeTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeTag_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *ExpungeTagArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeTagArgs(%+v)", *p)
}

type ExpungeTagResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewExpungeTagResult() *ExpungeTagResult {
	return &ExpungeTagResult{}
}

func (p *ExpungeTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeTagResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeTagResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeTagResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeTagResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ExpungeTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeTag_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeTagResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeTagResult(%+v)", *p)
}

type ListSearchesArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewListSearchesArgs() *ListSearchesArgs {
	return &ListSearchesArgs{}
}

func (p *ListSearchesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListSearchesArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListSearchesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listSearches_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListSearchesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListSearchesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListSearchesArgs(%+v)", *p)
}

type ListSearchesResult struct {
	Success         []*Types.SavedSearch        `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewListSearchesResult() *ListSearchesResult {
	return &ListSearchesResult{}
}

func (p *ListSearchesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListSearchesResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Types.SavedSearch, 0, size)
	for i := 0; i < size; i++ {
		_elem334 := Types.NewSavedSearch()
		if err := _elem334.Read(ctx, iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem334)
		}
		p.Success = append(p.Success, _elem334)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListSearchesResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListSearchesResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListSearchesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listSearches_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListSearchesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListSearchesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListSearchesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListSearchesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListSearchesResult(%+v)", *p)
}

type GetSearchArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetSearchArgs() *GetSearchArgs {
	return &GetSearchArgs{}
}

func (p *GetSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSearchArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetSearchArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSearch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetSearchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSearchArgs(%+v)", *p)
}

type GetSearchResult struct {
	Success           *Types.SavedSearch            `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetSearchResult() *GetSearchResult {
	return &GetSearchResult{}
}

func (p *GetSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSearchResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewSavedSearch()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetSearchResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetSearchResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetSearchResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSearch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetSearchResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetSearchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSearchResult(%+v)", *p)
}

type CreateSearchArgs struct {
	AuthenticationToken string             `thrift:"authenticationToken,1"`
	Search              *Types.SavedSearch `thrift:"search,2"`
}

func NewCreateSearchArgs() *CreateSearchArgs {
	return &CreateSearchArgs{}
}

func (p *CreateSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateSearchArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CreateSearchArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Search = Types.NewSavedSearch()
	if err := p.Search.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Search)
	}
	return nil
}

func (p *CreateSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createSearch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CreateSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Search != nil {
		if err := oprot.WriteFieldBegin(ctx, "search", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:search: %s", p, err)
		}
		if err := p.Search.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Search)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:search: %s", p, err)
		}
	}
	return err
}

func (p *CreateSearchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateSearchArgs(%+v)", *p)
}

type CreateSearchResult struct {
	Success         *Types.SavedSearch          `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewCreateSearchResult() *CreateSearchResult {
	return &CreateSearchResult{}
}

func (p *CreateSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateSearchResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewSavedSearch()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CreateSearchResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CreateSearchResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CreateSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createSearch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CreateSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CreateSearchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateSearchResult(%+v)", *p)
}

type UpdateSearchArgs struct {
	AuthenticationToken string             `thrift:"authenticationToken,1"`
	Search              *Types.SavedSearch `thrift:"search,2"`
}

func NewUpdateSearchArgs() *UpdateSearchArgs {
	return &UpdateSearchArgs{}
}

func (p *UpdateSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateSearchArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateSearchArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Search = Types.NewSavedSearch()
	if err := p.Search.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Search)
	}
	return nil
}

func (p *UpdateSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateSearch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Search != nil {
		if err := oprot.WriteFieldBegin(ctx, "search", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:search: %s", p, err)
		}
		if err := p.Search.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Search)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:search: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSearchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateSearchArgs(%+v)", *p)
}

type UpdateSearchResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUpdateSearchResult() *UpdateSearchResult {
	return &UpdateSearchResult{}
}

func (p *UpdateSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateSearchResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UpdateSearchResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateSearchResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateSearchResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateSearch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UpdateSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSearchResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSearchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateSearchResult(%+v)", *p)
}

type ExpungeSearchArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewExpungeSearchArgs() *ExpungeSearchArgs {
	return &ExpungeSearchArgs{}
}

func (p *ExpungeSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeSearchArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeSearchArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *ExpungeSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeSearch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *ExpungeSearchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeSearchArgs(%+v)", *p)
}

type ExpungeSearchResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewExpungeSearchResult() *ExpungeSearchResult {
	return &ExpungeSearchResult{}
}

func (p *ExpungeSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeSearchResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeSearchResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeSearchResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeSearchResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ExpungeSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeSearch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeSearchResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeSearchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeSearchResult(%+v)", *p)
}

type FindNotesArgs struct {
	AuthenticationToken string      `thrift:"authenticationToken,1"`
	Filter              *NoteFilter `thrift:"filter,2"`
	Offset              int32       `thrift:"offset,3"`
	MaxNotes            int32       `thrift:"maxNotes,4"`
}

func NewFindNotesArgs() *FindNotesArgs {
	return &FindNotesArgs{}
}

func (p *FindNotesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNotesArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *FindNotesArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Filter = NewNoteFilter()
	if err := p.Filter.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Filter)
	}
	return nil
}

func (p *FindNotesArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Offset = v
	}
	return nil
}

func (p *FindNotesArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.MaxNotes = v
	}
	return nil
}

func (p *FindNotesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNotes_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNotesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *FindNotesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Filter != nil {
		if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:filter: %s", p, err)
		}
		if err := p.Filter.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Filter)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:filter: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "offset", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:offset: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Offset)); err != nil {
		return fmt.Errorf("%T.offset (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:offset: %s", p, err)
	}
	return err
}

func (p *FindNotesArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "maxNotes", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:maxNotes: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.MaxNotes)); err != nil {
		return fmt.Errorf("%T.maxNotes (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:maxNotes: %s", p, err)
	}
	return err
}

func (p *FindNotesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNotesArgs(%+v)", *p)
}

type FindNotesResult struct {
	Success           *NoteList                     `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewFindNotesResult() *FindNotesResult {
	return &FindNotesResult{}
}

func (p *FindNotesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNotesResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewNoteList()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *FindNotesResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *FindNotesResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *FindNotesResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *FindNotesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNotes_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNotesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNotesResult(%+v)", *p)
}

type FindNoteOffsetArgs struct {
	AuthenticationToken string      `thrift:"authenticationToken,1"`
	Filter              *NoteFilter `thrift:"filter,2"`
	Guid                Types.Guid  `thrift:"guid,3"`
}

func NewFindNoteOffsetArgs() *FindNoteOffsetArgs {
	return &FindNoteOffsetArgs{}
}

func (p *FindNoteOffsetArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNoteOffsetArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *FindNoteOffsetArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Filter = NewNoteFilter()
	if err := p.Filter.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Filter)
	}
	return nil
}

func (p *FindNoteOffsetArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *FindNoteOffsetArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNoteOffset_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNoteOffsetArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *FindNoteOffsetArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Filter != nil {
		if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:filter: %s", p, err)
		}
		if err := p.Filter.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Filter)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:filter: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteOffsetArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:guid: %s", p, err)
	}
	return err
}

func (p *FindNoteOffsetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNoteOffsetArgs(%+v)", *p)
}

type FindNoteOffsetResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewFindNoteOffsetResult() *FindNoteOffsetResult {
	return &FindNoteOffsetResult{}
}

func (p *FindNoteOffsetResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNoteOffsetResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *FindNoteOffsetResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *FindNoteOffsetResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *FindNoteOffsetResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *FindNoteOffsetResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNoteOffset_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNoteOffsetResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *FindNoteOffsetResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteOffsetResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteOffsetResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteOffsetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNoteOffsetResult(%+v)", *p)
}

type FindNotesMetadataArgs struct {
	AuthenticationToken string                   `thrift:"authenticationToken,1"`
	Filter              *NoteFilter              `thrift:"filter,2"`
	Offset              int32                    `thrift:"offset,3"`
	MaxNotes            int32                    `thrift:"maxNotes,4"`
	ResultSpec          *NotesMetadataResultSpec `thrift:"resultSpec,5"`
}

func NewFindNotesMetadataArgs() *FindNotesMetadataArgs {
	return &FindNotesMetadataArgs{}
}

func (p *FindNotesMetadataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNotesMetadataArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *FindNotesMetadataArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Filter = NewNoteFilter()
	if err := p.Filter.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Filter)
	}
	return nil
}

func (p *FindNotesMetadataArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Offset = v
	}
	return nil
}

func (p *FindNotesMetadataArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.MaxNotes = v
	}
	return nil
}

func (p *FindNotesMetadataArgs) readField5(ctx context.Context, iprot thrift.TProtocol) error {
	p.ResultSpec = NewNotesMetadataResultSpec()
	if err := p.ResultSpec.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ResultSpec)
	}
	return nil
}

func (p *FindNotesMetadataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNotesMetadata_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField5(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNotesMetadataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *FindNotesMetadataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Filter != nil {
		if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:filter: %s", p, err)
		}
		if err := p.Filter.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Filter)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:filter: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesMetadataArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "offset", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:offset: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Offset)); err != nil {
		return fmt.Errorf("%T.offset (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:offset: %s", p, err)
	}
	return err
}

func (p *FindNotesMetadataArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "maxNotes", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:maxNotes: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.MaxNotes)); err != nil {
		return fmt.Errorf("%T.maxNotes (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:maxNotes: %s", p, err)
	}
	return err
}

func (p *FindNotesMetadataArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.ResultSpec != nil {
		if err := oprot.WriteFieldBegin(ctx, "resultSpec", thrift.STRUCT, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:resultSpec: %s", p, err)
		}
		if err := p.ResultSpec.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ResultSpec)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 5:resultSpec: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesMetadataArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNotesMetadataArgs(%+v)", *p)
}

type FindNotesMetadataResult struct {
	Success           *NotesMetadataList            `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewFindNotesMetadataResult() *FindNotesMetadataResult {
	return &FindNotesMetadataResult{}
}

func (p *FindNotesMetadataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNotesMetadataResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewNotesMetadataList()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *FindNotesMetadataResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *FindNotesMetadataResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *FindNotesMetadataResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *FindNotesMetadataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNotesMetadata_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNotesMetadataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesMetadataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesMetadataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesMetadataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *FindNotesMetadataResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNotesMetadataResult(%+v)", *p)
}

type FindNoteCountsArgs struct {
	AuthenticationToken string      `thrift:"authenticationToken,1"`
	Filter              *NoteFilter `thrift:"filter,2"`
	WithTrash           bool        `thrift:"withTrash,3"`
}

func NewFindNoteCountsArgs() *FindNoteCountsArgs {
	return &FindNoteCountsArgs{}
}

func (p *FindNoteCountsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNoteCountsArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *FindNoteCountsArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Filter = NewNoteFilter()
	if err := p.Filter.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Filter)
	}
	return nil
}

func (p *FindNoteCountsArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.WithTrash = v
	}
	return nil
}

func (p *FindNoteCountsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNoteCounts_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNoteCountsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *FindNoteCountsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Filter != nil {
		if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:filter: %s", p, err)
		}
		if err := p.Filter.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Filter)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:filter: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteCountsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withTrash", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:withTrash: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithTrash)); err != nil {
		return fmt.Errorf("%T.withTrash (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:withTrash: %s", p, err)
	}
	return err
}

func (p *FindNoteCountsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNoteCountsArgs(%+v)", *p)
}

type FindNoteCountsResult struct {
	Success           *NoteCollectionCounts         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewFindNoteCountsResult() *FindNoteCountsResult {
	return &FindNoteCountsResult{}
}

func (p *FindNoteCountsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindNoteCountsResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewNoteCollectionCounts()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *FindNoteCountsResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *FindNoteCountsResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *FindNoteCountsResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *FindNoteCountsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findNoteCounts_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindNoteCountsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteCountsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteCountsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteCountsResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *FindNoteCountsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindNoteCountsResult(%+v)", *p)
}

type GetNoteArgs struct {
	AuthenticationToken        string     `thrift:"authenticationToken,1"`
	Guid                       Types.Guid `thrift:"guid,2"`
	WithContent                bool       `thrift:"withContent,3"`
	WithResourcesData          bool       `thrift:"withResourcesData,4"`
	WithResourcesRecognition   bool       `thrift:"withResourcesRecognition,5"`
	WithResourcesAlternateData bool       `thrift:"withResourcesAlternateData,6"`
}

func NewGetNoteArgs() *GetNoteArgs {
	return &GetNoteArgs{}
}

func (p *GetNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(ctx, iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetNoteArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.WithContent = v
	}
	return nil
}

func (p *GetNoteArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.WithResourcesData = v
	}
	return nil
}

func (p *GetNoteArgs) readField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.WithResourcesRecognition = v
	}
	return nil
}

func (p *GetNoteArgs) readField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.WithResourcesAlternateData = v
	}
	return nil
}

func (p *GetNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField5(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField6(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetNoteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withContent", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:withContent: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithContent)); err != nil {
		return fmt.Errorf("%T.withContent (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:withContent: %s", p, err)
	}
	return err
}

func (p *GetNoteArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withResourcesData", thrift.BOOL, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:withResourcesData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithResourcesData)); err != nil {
		return fmt.Errorf("%T.withResourcesData (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:withResourcesData: %s", p, err)
	}
	return err
}

func (p *GetNoteArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withResourcesRecognition", thrift.BOOL, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:withResourcesRecognition: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithResourcesRecognition)); err != nil {
		return fmt.Errorf("%T.withResourcesRecognition (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 5:withResourcesRecognition: %s", p, err)
	}
	return err
}

func (p *GetNoteArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withResourcesAlternateData", thrift.BOOL, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:withResourcesAlternateData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithResourcesAlternateData)); err != nil {
		return fmt.Errorf("%T.withResourcesAlternateData (6) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 6:withResourcesAlternateData: %s", p, err)
	}
	return err
}

func (p *GetNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteArgs(%+v)", *p)
}

type GetNoteResult struct {
	Success           *Types.Note                   `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNoteResult() *GetNoteResult {
	return &GetNoteResult{}
}

func (p *GetNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNote()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteResult(%+v)", *p)
}

type GetNoteApplicationDataArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetNoteApplicationDataArgs() *GetNoteApplicationDataArgs {
	return &GetNoteApplicationDataArgs{}
}

func (p *GetNoteApplicationDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteApplicationDataArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteApplicationDataArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetNoteApplicationDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteApplicationData_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteApplicationDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteApplicationDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetNoteApplicationDataArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteApplicationDataArgs(%+v)", *p)
}

type GetNoteApplicationDataResult struct {
	Success           *Types.LazyMap                `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNoteApplicationDataResult() *GetNoteApplicationDataResult {
	return &GetNoteApplicationDataResult{}
}

func (p *GetNoteApplicationDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteApplicationDataResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewLazyMap()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetNoteApplicationDataResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteApplicationDataResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteApplicationDataResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNoteApplicationDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteApplicationData_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteApplicationDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteApplicationDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteApplicationDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteApplicationDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteApplicationDataResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteApplicationDataResult(%+v)", *p)
}

type GetNoteApplicationDataEntryArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	Key                 string     `thrift:"key,3"`
}

func NewGetNoteApplicationDataEntryArgs() *GetNoteApplicationDataEntryArgs {
	return &GetNoteApplicationDataEntryArgs{}
}

func (p *GetNoteApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteApplicationDataEntryArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetNoteApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteApplicationDataEntry_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetNoteApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:key: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
		return fmt.Errorf("%T.key (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:key: %s", p, err)
	}
	return err
}

func (p *GetNoteApplicationDataEntryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteApplicationDataEntryArgs(%+v)", *p)
}

type GetNoteApplicationDataEntryResult struct {
	Success           string                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNoteApplicationDataEntryResult() *GetNoteApplicationDataEntryResult {
	return &GetNoteApplicationDataEntryResult{}
}

func (p *GetNoteApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetNoteApplicationDataEntryResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteApplicationDataEntry_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetNoteApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteApplicationDataEntryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteApplicationDataEntryResult(%+v)", *p)
}

type SetNoteApplicationDataEntryArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	Key                 string     `thrift:"key,3"`
	Value               string     `thrift:"value,4"`
}

func NewSetNoteApplicationDataEntryArgs() *SetNoteApplicationDataEntryArgs {
	return &SetNoteApplicationDataEntryArgs{}
}

func (p *SetNoteApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *SetNoteApplicationDataEntryArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *SetNoteApplicationDataEntryArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Value = v
	}
	return nil
}

func (p *SetNoteApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setNoteApplicationDataEntry_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *SetNoteApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *SetNoteApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:key: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
		return fmt.Errorf("%T.key (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:key: %s", p, err)
	}
	return err
}

func (p *SetNoteApplicationDataEntryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:value: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
		return fmt.Errorf("%T.value (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:value: %s", p, err)
	}
	return err
}

func (p *SetNoteApplicationDataEntryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetNoteApplicationDataEntryArgs(%+v)", *p)
}

type SetNoteApplicationDataEntryResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewSetNoteApplicationDataEntryResult() *SetNoteApplicationDataEntryResult {
	return &SetNoteApplicationDataEntryResult{}
}

func (p *SetNoteApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SetNoteApplicationDataEntryResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setNoteApplicationDataEntry_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetNoteApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SetNoteApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *SetNoteApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *SetNoteApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *SetNoteApplicationDataEntryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetNoteApplicationDataEntryResult(%+v)", *p)
}

type UnsetNoteApplicationDataEntryArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	Key                 string     `thrift:"key,3"`
}

func NewUnsetNoteApplicationDataEntryArgs() *UnsetNoteApplicationDataEntryArgs {
	return &UnsetNoteApplicationDataEntryArgs{}
}

func (p *UnsetNoteApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "unsetNoteApplicationDataEntry_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UnsetNoteApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *UnsetNoteApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:key: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
		return fmt.Errorf("%T.key (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:key: %s", p, err)
	}
	return err
}

func (p *UnsetNoteApplicationDataEntryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnsetNoteApplicationDataEntryArgs(%+v)", *p)
}

type UnsetNoteApplicationDataEntryResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUnsetNoteApplicationDataEntryResult() *UnsetNoteApplicationDataEntryResult {
	return &UnsetNoteApplicationDataEntryResult{}
}

func (p *UnsetNoteApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "unsetNoteApplicationDataEntry_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UnsetNoteApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UnsetNoteApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UnsetNoteApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UnsetNoteApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UnsetNoteApplicationDataEntryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnsetNoteApplicationDataEntryResult(%+v)", *p)
}

type GetNoteContentArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetNoteContentArgs() *GetNoteContentArgs {
	return &GetNoteContentArgs{}
}

func (p *GetNoteContentArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteContentArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteContentArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetNoteContentArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteContent_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteContentArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteContentArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetNoteContentArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteContentArgs(%+v)", *p)
}

type GetNoteContentResult struct {
	Success           string                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNoteContentResult() *GetNoteContentResult {
	return &GetNoteContentResult{}
}

func (p *GetNoteContentResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteContentResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetNoteContentResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteContentResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteContentResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNoteContentResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteContent_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteContentResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetNoteContentResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteContentResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteContentResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteContentResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteContentResult(%+v)", *p)
}

type GetNoteSearchTextArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	NoteOnly            bool       `thrift:"noteOnly,3"`
	TokenizeForIndexing bool       `thrift:"tokenizeForIndexing,4"`
}

func NewGetNoteSearchTextArgs() *GetNoteSearchTextArgs {
	return &GetNoteSearchTextArgs{}
}

func (p *GetNoteSearchTextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteSearchTextArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteSearchTextArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetNoteSearchTextArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.NoteOnly = v
	}
	return nil
}

func (p *GetNoteSearchTextArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.TokenizeForIndexing = v
	}
	return nil
}

func (p *GetNoteSearchTextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteSearchText_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteSearchTextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteSearchTextArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetNoteSearchTextArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "noteOnly", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:noteOnly: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.NoteOnly)); err != nil {
		return fmt.Errorf("%T.noteOnly (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:noteOnly: %s", p, err)
	}
	return err
}

func (p *GetNoteSearchTextArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tokenizeForIndexing", thrift.BOOL, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:tokenizeForIndexing: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.TokenizeForIndexing)); err != nil {
		return fmt.Errorf("%T.tokenizeForIndexing (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:tokenizeForIndexing: %s", p, err)
	}
	return err
}

func (p *GetNoteSearchTextArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteSearchTextArgs(%+v)", *p)
}

type GetNoteSearchTextResult struct {
	Success           string                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNoteSearchTextResult() *GetNoteSearchTextResult {
	return &GetNoteSearchTextResult{}
}

func (p *GetNoteSearchTextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteSearchTextResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetNoteSearchTextResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteSearchTextResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteSearchTextResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNoteSearchTextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteSearchText_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteSearchTextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetNoteSearchTextResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteSearchTextResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteSearchTextResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteSearchTextResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteSearchTextResult(%+v)", *p)
}

type GetResourceSearchTextArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetResourceSearchTextArgs() *GetResourceSearchTextArgs {
	return &GetResourceSearchTextArgs{}
}

func (p *GetResourceSearchTextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceSearchTextArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceSearchTextArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceSearchTextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceSearchText_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceSearchTextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceSearchTextArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceSearchTextArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceSearchTextArgs(%+v)", *p)
}

type GetResourceSearchTextResult struct {
	Success           string                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceSearchTextResult() *GetResourceSearchTextResult {
	return &GetResourceSearchTextResult{}
}

func (p *GetResourceSearchTextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceSearchTextResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetResourceSearchTextResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceSearchTextResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceSearchTextResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceSearchTextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceSearchText_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceSearchTextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetResourceSearchTextResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceSearchTextResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceSearchTextResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceSearchTextResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceSearchTextResult(%+v)", *p)
}

type GetNoteTagNamesArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetNoteTagNamesArgs() *GetNoteTagNamesArgs {
	return &GetNoteTagNamesArgs{}
}

func (p *GetNoteTagNamesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteTagNamesArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteTagNamesArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetNoteTagNamesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteTagNames_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteTagNamesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteTagNamesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetNoteTagNamesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteTagNamesArgs(%+v)", *p)
}

type GetNoteTagNamesResult struct {
	Success           []string                      `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNoteTagNamesResult() *GetNoteTagNamesResult {
	return &GetNoteTagNamesResult{}
}

func (p *GetNoteTagNamesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteTagNamesResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem335 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem335 = v
		}
		p.Success = append(p.Success, _elem335)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetNoteTagNamesResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteTagNamesResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteTagNamesResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNoteTagNamesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteTagNames_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteTagNamesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteTagNamesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteTagNamesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteTagNamesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteTagNamesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteTagNamesResult(%+v)", *p)
}

type CreateNoteArgs struct {
	AuthenticationToken string      `thrift:"authenticationToken,1"`
	Note                *Types.Note `thrift:"note,2"`
}

func NewCreateNoteArgs() *CreateNoteArgs {
	return &CreateNoteArgs{}
}

func (p *CreateNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CreateNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Note = Types.NewNote()
	if err := p.Note.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Note)
	}
	return nil
}

func (p *CreateNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CreateNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Note != nil {
		if err := oprot.WriteFieldBegin(ctx, "note", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:note: %s", p, err)
		}
		if err := p.Note.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Note)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:note: %s", p, err)
		}
	}
	return err
}

func (p *CreateNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNoteArgs(%+v)", *p)
}

type CreateNoteResult struct {
	Success           *Types.Note                   `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewCreateNoteResult() *CreateNoteResult {
	return &CreateNoteResult{}
}

func (p *CreateNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNote()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CreateNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CreateNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CreateNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *CreateNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CreateNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CreateNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *CreateNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNoteResult(%+v)", *p)
}

type UpdateNoteArgs struct {
	AuthenticationToken string      `thrift:"authenticationToken,1"`
	Note                *Types.Note `thrift:"note,2"`
}

func NewUpdateNoteArgs() *UpdateNoteArgs {
	return &UpdateNoteArgs{}
}

func (p *UpdateNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Note = Types.NewNote()
	if err := p.Note.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Note)
	}
	return nil
}

func (p *UpdateNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Note != nil {
		if err := oprot.WriteFieldBegin(ctx, "note", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:note: %s", p, err)
		}
		if err := p.Note.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Note)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:note: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateNoteArgs(%+v)", *p)
}

type UpdateNoteResult struct {
	Success           *Types.Note                   `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUpdateNoteResult() *UpdateNoteResult {
	return &UpdateNoteResult{}
}

func (p *UpdateNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNote()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *UpdateNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateNoteResult(%+v)", *p)
}

type DeleteNoteArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewDeleteNoteArgs() *DeleteNoteArgs {
	return &DeleteNoteArgs{}
}

func (p *DeleteNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *DeleteNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *DeleteNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *DeleteNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *DeleteNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteNoteArgs(%+v)", *p)
}

type DeleteNoteResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewDeleteNoteResult() *DeleteNoteResult {
	return &DeleteNoteResult{}
}

func (p *DeleteNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *DeleteNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *DeleteNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *DeleteNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *DeleteNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "deleteNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DeleteNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *DeleteNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *DeleteNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *DeleteNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteNoteResult(%+v)", *p)
}

type ExpungeNoteArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewExpungeNoteArgs() *ExpungeNoteArgs {
	return &ExpungeNoteArgs{}
}

func (p *ExpungeNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *ExpungeNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *ExpungeNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeNoteArgs(%+v)", *p)
}

type ExpungeNoteResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewExpungeNoteResult() *ExpungeNoteResult {
	return &ExpungeNoteResult{}
}

func (p *ExpungeNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ExpungeNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeNoteResult(%+v)", *p)
}

type ExpungeNotesArgs struct {
	AuthenticationToken string       `thrift:"authenticationToken,1"`
	NoteGuids           []Types.Guid `thrift:"noteGuids,2"`
}

func NewExpungeNotesArgs() *ExpungeNotesArgs {
	return &ExpungeNotesArgs{}
}

func (p *ExpungeNotesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeNotesArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeNotesArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.NoteGuids = make([]Types.Guid, 0, size)
	for i := 0; i < size; i++ {
		var _elem336 Types.Guid
		if v, err := iprot.ReadString(ctx); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem336 = Types.Guid(v)
		}
		p.NoteGuids = append(p.NoteGuids, _elem336)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ExpungeNotesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeNotes_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeNotesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeNotesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NoteGuids != nil {
		if err := oprot.WriteFieldBegin(ctx, "noteGuids", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:noteGuids: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.NoteGuids)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.NoteGuids {
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:noteGuids: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNotesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeNotesArgs(%+v)", *p)
}

type ExpungeNotesResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewExpungeNotesResult() *ExpungeNotesResult {
	return &ExpungeNotesResult{}
}

func (p *ExpungeNotesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeNotesResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeNotesResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeNotesResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeNotesResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ExpungeNotesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeNotes_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeNotesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeNotesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNotesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNotesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeNotesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeNotesResult(%+v)", *p)
}

type ExpungeInactiveNotesArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewExpungeInactiveNotesArgs() *ExpungeInactiveNotesArgs {
	return &ExpungeInactiveNotesArgs{}
}

func (p *ExpungeInactiveNotesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeInactiveNotesArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeInactiveNotesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeInactiveNotes_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeInactiveNotesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeInactiveNotesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeInactiveNotesArgs(%+v)", *p)
}

type ExpungeInactiveNotesResult struct {
	Success         int32                       `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewExpungeInactiveNotesResult() *ExpungeInactiveNotesResult {
	return &ExpungeInactiveNotesResult{}
}

func (p *ExpungeInactiveNotesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeInactiveNotesResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeInactiveNotesResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeInactiveNotesResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeInactiveNotesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeInactiveNotes_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeInactiveNotesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeInactiveNotesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeInactiveNotesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeInactiveNotesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeInactiveNotesResult(%+v)", *p)
}

type CopyNoteArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	NoteGuid            Types.Guid `thrift:"noteGuid,2"`
	ToNotebookGuid      Types.Guid `thrift:"toNotebookGuid,3"`
}

func NewCopyNoteArgs() *CopyNoteArgs {
	return &CopyNoteArgs{}
}

func (p *CopyNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CopyNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CopyNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NoteGuid = Types.Guid(v)
	}
	return nil
}

func (p *CopyNoteArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ToNotebookGuid = Types.Guid(v)
	}
	return nil
}

func (p *CopyNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "copyNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CopyNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CopyNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:noteGuid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
		return fmt.Errorf("%T.noteGuid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:noteGuid: %s", p, err)
	}
	return err
}

func (p *CopyNoteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "toNotebookGuid", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:toNotebookGuid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.ToNotebookGuid)); err != nil {
		return fmt.Errorf("%T.toNotebookGuid (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:toNotebookGuid: %s", p, err)
	}
	return err
}

func (p *CopyNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CopyNoteArgs(%+v)", *p)
}

type CopyNoteResult struct {
	Success           *Types.Note                   `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewCopyNoteResult() *CopyNoteResult {
	return &CopyNoteResult{}
}

func (p *CopyNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CopyNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNote()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CopyNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CopyNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CopyNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *CopyNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "copyNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CopyNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CopyNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CopyNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CopyNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *CopyNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CopyNoteResult(%+v)", *p)
}

type ListNoteVersionsArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	NoteGuid            Types.Guid `thrift:"noteGuid,2"`
}

func NewListNoteVersionsArgs() *ListNoteVersionsArgs {
	return &ListNoteVersionsArgs{}
}

func (p *ListNoteVersionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNoteVersionsArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListNoteVersionsArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NoteGuid = Types.Guid(v)
	}
	return nil
}

func (p *ListNoteVersionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listNoteVersions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNoteVersionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListNoteVersionsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:noteGuid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
		return fmt.Errorf("%T.noteGuid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:noteGuid: %s", p, err)
	}
	return err
}

func (p *ListNoteVersionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNoteVersionsArgs(%+v)", *p)
}

type ListNoteVersionsResult struct {
	Success           []*NoteVersionId              `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewListNoteVersionsResult() *ListNoteVersionsResult {
	return &ListNoteVersionsResult{}
}

func (p *ListNoteVersionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNoteVersionsResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*NoteVersionId, 0, size)
	for i := 0; i < size; i++ {
		_elem337 := NewNoteVersionId()
		if err := _elem337.Read(ctx, iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem337)
		}
		p.Success = append(p.Success, _elem337)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListNoteVersionsResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListNoteVersionsResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListNoteVersionsResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ListNoteVersionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listNoteVersions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNoteVersionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListNoteVersionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListNoteVersionsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListNoteVersionsResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ListNoteVersionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNoteVersionsResult(%+v)", *p)
}

type GetNoteVersionArgs struct {
	AuthenticationToken        string     `thrift:"authenticationToken,1"`
	NoteGuid                   Types.Guid `thrift:"noteGuid,2"`
	UpdateSequenceNum          int32      `thrift:"updateSequenceNum,3"`
	WithResourcesData          bool       `thrift:"withResourcesData,4"`
	WithResourcesRecognition   bool       `thrift:"withResourcesRecognition,5"`
	WithResourcesAlternateData bool       `thrift:"withResourcesAlternateData,6"`
}

func NewGetNoteVersionArgs() *GetNoteVersionArgs {
	return &GetNoteVersionArgs{}
}

func (p *GetNoteVersionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(ctx, iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteVersionArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteVersionArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NoteGuid = Types.Guid(v)
	}
	return nil
}

func (p *GetNoteVersionArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.UpdateSequenceNum = v
	}
	return nil
}

func (p *GetNoteVersionArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.WithResourcesData = v
	}
	return nil
}

func (p *GetNoteVersionArgs) readField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.WithResourcesRecognition = v
	}
	return nil
}

func (p *GetNoteVersionArgs) readField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.WithResourcesAlternateData = v
	}
	return nil
}

func (p *GetNoteVersionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteVersion_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField5(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField6(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteVersionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteVersionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:noteGuid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
		return fmt.Errorf("%T.noteGuid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:noteGuid: %s", p, err)
	}
	return err
}

func (p *GetNoteVersionArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "updateSequenceNum", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:updateSequenceNum: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.UpdateSequenceNum)); err != nil {
		return fmt.Errorf("%T.updateSequenceNum (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:updateSequenceNum: %s", p, err)
	}
	return err
}

func (p *GetNoteVersionArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withResourcesData", thrift.BOOL, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:withResourcesData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithResourcesData)); err != nil {
		return fmt.Errorf("%T.withResourcesData (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:withResourcesData: %s", p, err)
	}
	return err
}

func (p *GetNoteVersionArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withResourcesRecognition", thrift.BOOL, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:withResourcesRecognition: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithResourcesRecognition)); err != nil {
		return fmt.Errorf("%T.withResourcesRecognition (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 5:withResourcesRecognition: %s", p, err)
	}
	return err
}

func (p *GetNoteVersionArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withResourcesAlternateData", thrift.BOOL, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:withResourcesAlternateData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithResourcesAlternateData)); err != nil {
		return fmt.Errorf("%T.withResourcesAlternateData (6) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 6:withResourcesAlternateData: %s", p, err)
	}
	return err
}

func (p *GetNoteVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteVersionArgs(%+v)", *p)
}

type GetNoteVersionResult struct {
	Success           *Types.Note                   `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetNoteVersionResult() *GetNoteVersionResult {
	return &GetNoteVersionResult{}
}

func (p *GetNoteVersionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteVersionResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNote()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetNoteVersionResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteVersionResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteVersionResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetNoteVersionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getNoteVersion_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteVersionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteVersionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteVersionResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteVersionResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteVersionResult(%+v)", *p)
}

type GetResourceArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	WithData            bool       `thrift:"withData,3"`
	WithRecognition     bool       `thrift:"withRecognition,4"`
	WithAttributes      bool       `thrift:"withAttributes,5"`
	WithAlternateData   bool       `thrift:"withAlternateData,6"`
}

func NewGetResourceArgs() *GetResourceArgs {
	return &GetResourceArgs{}
}

func (p *GetResourceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(ctx, iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.WithData = v
	}
	return nil
}

func (p *GetResourceArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.WithRecognition = v
	}
	return nil
}

func (p *GetResourceArgs) readField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.WithAttributes = v
	}
	return nil
}

func (p *GetResourceArgs) readField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.WithAlternateData = v
	}
	return nil
}

func (p *GetResourceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResource_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField5(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField6(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withData", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:withData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithData)); err != nil {
		return fmt.Errorf("%T.withData (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:withData: %s", p, err)
	}
	return err
}

func (p *GetResourceArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withRecognition", thrift.BOOL, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:withRecognition: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithRecognition)); err != nil {
		return fmt.Errorf("%T.withRecognition (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:withRecognition: %s", p, err)
	}
	return err
}

func (p *GetResourceArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withAttributes", thrift.BOOL, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:withAttributes: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithAttributes)); err != nil {
		return fmt.Errorf("%T.withAttributes (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 5:withAttributes: %s", p, err)
	}
	return err
}

func (p *GetResourceArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withAlternateData", thrift.BOOL, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:withAlternateData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithAlternateData)); err != nil {
		return fmt.Errorf("%T.withAlternateData (6) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 6:withAlternateData: %s", p, err)
	}
	return err
}

func (p *GetResourceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceArgs(%+v)", *p)
}

type GetResourceResult struct {
	Success           *Types.Resource               `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceResult() *GetResourceResult {
	return &GetResourceResult{}
}

func (p *GetResourceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewResource()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetResourceResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResource_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceResult(%+v)", *p)
}

type GetResourceApplicationDataArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetResourceApplicationDataArgs() *GetResourceApplicationDataArgs {
	return &GetResourceApplicationDataArgs{}
}

func (p *GetResourceApplicationDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceApplicationDataArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceApplicationDataArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceApplicationDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceApplicationData_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceApplicationDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceApplicationDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceApplicationDataArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceApplicationDataArgs(%+v)", *p)
}

type GetResourceApplicationDataResult struct {
	Success           *Types.LazyMap                `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceApplicationDataResult() *GetResourceApplicationDataResult {
	return &GetResourceApplicationDataResult{}
}

func (p *GetResourceApplicationDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceApplicationDataResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewLazyMap()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetResourceApplicationDataResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceApplicationDataResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceApplicationDataResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceApplicationDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceApplicationData_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceApplicationDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceApplicationDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceApplicationDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceApplicationDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceApplicationDataResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceApplicationDataResult(%+v)", *p)
}

type GetResourceApplicationDataEntryArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	Key                 string     `thrift:"key,3"`
}

func NewGetResourceApplicationDataEntryArgs() *GetResourceApplicationDataEntryArgs {
	return &GetResourceApplicationDataEntryArgs{}
}

func (p *GetResourceApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceApplicationDataEntryArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetResourceApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceApplicationDataEntry_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:key: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
		return fmt.Errorf("%T.key (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:key: %s", p, err)
	}
	return err
}

func (p *GetResourceApplicationDataEntryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceApplicationDataEntryArgs(%+v)", *p)
}

type GetResourceApplicationDataEntryResult struct {
	Success           string                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceApplicationDataEntryResult() *GetResourceApplicationDataEntryResult {
	return &GetResourceApplicationDataEntryResult{}
}

func (p *GetResourceApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetResourceApplicationDataEntryResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceApplicationDataEntry_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetResourceApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceApplicationDataEntryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceApplicationDataEntryResult(%+v)", *p)
}

type SetResourceApplicationDataEntryArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	Key                 string     `thrift:"key,3"`
	Value               string     `thrift:"value,4"`
}

func NewSetResourceApplicationDataEntryArgs() *SetResourceApplicationDataEntryArgs {
	return &SetResourceApplicationDataEntryArgs{}
}

func (p *SetResourceApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *SetResourceApplicationDataEntryArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *SetResourceApplicationDataEntryArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Value = v
	}
	return nil
}

func (p *SetResourceApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setResourceApplicationDataEntry_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *SetResourceApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *SetResourceApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:key: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
		return fmt.Errorf("%T.key (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:key: %s", p, err)
	}
	return err
}

func (p *SetResourceApplicationDataEntryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:value: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
		return fmt.Errorf("%T.value (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:value: %s", p, err)
	}
	return err
}

func (p *SetResourceApplicationDataEntryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetResourceApplicationDataEntryArgs(%+v)", *p)
}

type SetResourceApplicationDataEntryResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewSetResourceApplicationDataEntryResult() *SetResourceApplicationDataEntryResult {
	return &SetResourceApplicationDataEntryResult{}
}

func (p *SetResourceApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SetResourceApplicationDataEntryResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setResourceApplicationDataEntry_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetResourceApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SetResourceApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *SetResourceApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *SetResourceApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *SetResourceApplicationDataEntryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetResourceApplicationDataEntryResult(%+v)", *p)
}

type UnsetResourceApplicationDataEntryArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
	Key                 string     `thrift:"key,3"`
}

func NewUnsetResourceApplicationDataEntryArgs() *UnsetResourceApplicationDataEntryArgs {
	return &UnsetResourceApplicationDataEntryArgs{}
}

func (p *UnsetResourceApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "unsetResourceApplicationDataEntry_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UnsetResourceApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *UnsetResourceApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:key: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
		return fmt.Errorf("%T.key (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:key: %s", p, err)
	}
	return err
}

func (p *UnsetResourceApplicationDataEntryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnsetResourceApplicationDataEntryArgs(%+v)", *p)
}

type UnsetResourceApplicationDataEntryResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUnsetResourceApplicationDataEntryResult() *UnsetResourceApplicationDataEntryResult {
	return &UnsetResourceApplicationDataEntryResult{}
}

func (p *UnsetResourceApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "unsetResourceApplicationDataEntry_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UnsetResourceApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UnsetResourceApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UnsetResourceApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UnsetResourceApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UnsetResourceApplicationDataEntryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnsetResourceApplicationDataEntryResult(%+v)", *p)
}

type UpdateResourceArgs struct {
	AuthenticationToken string          `thrift:"authenticationToken,1"`
	Resource            *Types.Resource `thrift:"resource,2"`
}

func NewUpdateResourceArgs() *UpdateResourceArgs {
	return &UpdateResourceArgs{}
}

func (p *UpdateResourceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateResourceArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateResourceArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Resource = Types.NewResource()
	if err := p.Resource.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Resource)
	}
	return nil
}

func (p *UpdateResourceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateResource_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateResourceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateResourceArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Resource != nil {
		if err := oprot.WriteFieldBegin(ctx, "resource", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:resource: %s", p, err)
		}
		if err := p.Resource.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Resource)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:resource: %s", p, err)
		}
	}
	return err
}

func (p *UpdateResourceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateResourceArgs(%+v)", *p)
}

type UpdateResourceResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUpdateResourceResult() *UpdateResourceResult {
	return &UpdateResourceResult{}
}

func (p *UpdateResourceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateResourceResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UpdateResourceResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateResourceResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateResourceResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateResourceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateResource_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateResourceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UpdateResourceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateResourceResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateResourceResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateResourceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateResourceResult(%+v)", *p)
}

type GetResourceDataArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetResourceDataArgs() *GetResourceDataArgs {
	return &GetResourceDataArgs{}
}

func (p *GetResourceDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceDataArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceDataArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceData_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceDataArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceDataArgs(%+v)", *p)
}

type GetResourceDataResult struct {
	Success           []byte                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceDataResult() *GetResourceDataResult {
	return &GetResourceDataResult{}
}

func (p *GetResourceDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceDataResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetResourceDataResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceDataResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceDataResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceData_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.COMPACT_BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(ctx, p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceDataResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceDataResult(%+v)", *p)
}

type GetResourceByHashArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	NoteGuid            Types.Guid `thrift:"noteGuid,2"`
	ContentHash         []byte     `thrift:"contentHash,3"`
	WithData            bool       `thrift:"withData,4"`
	WithRecognition     bool       `thrift:"withRecognition,5"`
	WithAlternateData   bool       `thrift:"withAlternateData,6"`
}

func NewGetResourceByHashArgs() *GetResourceByHashArgs {
	return &GetResourceByHashArgs{}
}

func (p *GetResourceByHashArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(ctx, iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceByHashArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceByHashArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NoteGuid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceByHashArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ContentHash = v
	}
	return nil
}

func (p *GetResourceByHashArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.WithData = v
	}
	return nil
}

func (p *GetResourceByHashArgs) readField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.WithRecognition = v
	}
	return nil
}

func (p *GetResourceByHashArgs) readField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.WithAlternateData = v
	}
	return nil
}

func (p *GetResourceByHashArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceByHash_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField5(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField6(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceByHashArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceByHashArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:noteGuid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
		return fmt.Errorf("%T.noteGuid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:noteGuid: %s", p, err)
	}
	return err
}

func (p *GetResourceByHashArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.ContentHash != nil {
		if err := oprot.WriteFieldBegin(ctx, "contentHash", thrift.COMPACT_BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:contentHash: %s", p, err)
		}
		if err := oprot.WriteBinary(ctx, p.ContentHash); err != nil {
			return fmt.Errorf("%T.contentHash (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:contentHash: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceByHashArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withData", thrift.BOOL, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:withData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithData)); err != nil {
		return fmt.Errorf("%T.withData (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 4:withData: %s", p, err)
	}
	return err
}

func (p *GetResourceByHashArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withRecognition", thrift.BOOL, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:withRecognition: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithRecognition)); err != nil {
		return fmt.Errorf("%T.withRecognition (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 5:withRecognition: %s", p, err)
	}
	return err
}

func (p *GetResourceByHashArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "withAlternateData", thrift.BOOL, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:withAlternateData: %s", p, err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WithAlternateData)); err != nil {
		return fmt.Errorf("%T.withAlternateData (6) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 6:withAlternateData: %s", p, err)
	}
	return err
}

func (p *GetResourceByHashArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceByHashArgs(%+v)", *p)
}

type GetResourceByHashResult struct {
	Success           *Types.Resource               `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceByHashResult() *GetResourceByHashResult {
	return &GetResourceByHashResult{}
}

func (p *GetResourceByHashResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceByHashResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewResource()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetResourceByHashResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceByHashResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceByHashResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceByHashResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceByHash_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceByHashResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceByHashResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceByHashResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceByHashResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceByHashResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceByHashResult(%+v)", *p)
}

type GetResourceRecognitionArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetResourceRecognitionArgs() *GetResourceRecognitionArgs {
	return &GetResourceRecognitionArgs{}
}

func (p *GetResourceRecognitionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceRecognitionArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceRecognitionArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceRecognitionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceRecognition_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceRecognitionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceRecognitionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceRecognitionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceRecognitionArgs(%+v)", *p)
}

type GetResourceRecognitionResult struct {
	Success           []byte                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceRecognitionResult() *GetResourceRecognitionResult {
	return &GetResourceRecognitionResult{}
}

func (p *GetResourceRecognitionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceRecognitionResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetResourceRecognitionResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceRecognitionResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceRecognitionResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceRecognitionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceRecognition_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceRecognitionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.COMPACT_BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(ctx, p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceRecognitionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceRecognitionResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceRecognitionResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceRecognitionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceRecognitionResult(%+v)", *p)
}

type GetResourceAlternateDataArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetResourceAlternateDataArgs() *GetResourceAlternateDataArgs {
	return &GetResourceAlternateDataArgs{}
}

func (p *GetResourceAlternateDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceAlternateDataArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceAlternateDataArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceAlternateDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceAlternateData_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceAlternateDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceAlternateDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceAlternateDataArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceAlternateDataArgs(%+v)", *p)
}

type GetResourceAlternateDataResult struct {
	Success           []byte                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceAlternateDataResult() *GetResourceAlternateDataResult {
	return &GetResourceAlternateDataResult{}
}

func (p *GetResourceAlternateDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceAlternateDataResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetResourceAlternateDataResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceAlternateDataResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceAlternateDataResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceAlternateDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceAlternateData_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceAlternateDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.COMPACT_BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(ctx, p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAlternateDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAlternateDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAlternateDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAlternateDataResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceAlternateDataResult(%+v)", *p)
}

type GetResourceAttributesArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewGetResourceAttributesArgs() *GetResourceAttributesArgs {
	return &GetResourceAttributesArgs{}
}

func (p *GetResourceAttributesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceAttributesArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetResourceAttributesArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *GetResourceAttributesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceAttributes_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceAttributesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetResourceAttributesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *GetResourceAttributesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceAttributesArgs(%+v)", *p)
}

type GetResourceAttributesResult struct {
	Success           *Types.ResourceAttributes     `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewGetResourceAttributesResult() *GetResourceAttributesResult {
	return &GetResourceAttributesResult{}
}

func (p *GetResourceAttributesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResourceAttributesResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewResourceAttributes()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetResourceAttributesResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetResourceAttributesResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetResourceAttributesResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetResourceAttributesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getResourceAttributes_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResourceAttributesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAttributesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAttributesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAttributesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetResourceAttributesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResourceAttributesResult(%+v)", *p)
}

type GetPublicNotebookArgs struct {
	UserId    Types.UserID `thrift:"userId,1"`
	PublicUri string       `thrift:"publicUri,2"`
}

func NewGetPublicNotebookArgs() *GetPublicNotebookArgs {
	return &GetPublicNotebookArgs{}
}

func (p *GetPublicNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPublicNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.UserId = Types.UserID(v)
	}
	return nil
}

func (p *GetPublicNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.PublicUri = v
	}
	return nil
}

func (p *GetPublicNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getPublicNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPublicNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "userId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:userId: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.UserId)); err != nil {
		return fmt.Errorf("%T.userId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:userId: %s", p, err)
	}
	return err
}

func (p *GetPublicNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "publicUri", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:publicUri: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.PublicUri)); err != nil {
		return fmt.Errorf("%T.publicUri (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:publicUri: %s", p, err)
	}
	return err
}

func (p *GetPublicNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPublicNotebookArgs(%+v)", *p)
}

type GetPublicNotebookResult struct {
	Success           *Types.Notebook               `thrift:"success,0"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
}

func NewGetPublicNotebookResult() *GetPublicNotebookResult {
	return &GetPublicNotebookResult{}
}

func (p *GetPublicNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPublicNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewNotebook()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetPublicNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetPublicNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetPublicNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getPublicNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPublicNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPublicNotebookResult(%+v)", *p)
}

type CreateSharedNotebookArgs struct {
	AuthenticationToken string                `thrift:"authenticationToken,1"`
	SharedNotebook      *Types.SharedNotebook `thrift:"sharedNotebook,2"`
}

func NewCreateSharedNotebookArgs() *CreateSharedNotebookArgs {
	return &CreateSharedNotebookArgs{}
}

func (p *CreateSharedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateSharedNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CreateSharedNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SharedNotebook = Types.NewSharedNotebook()
	if err := p.SharedNotebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SharedNotebook)
	}
	return nil
}

func (p *CreateSharedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createSharedNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateSharedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CreateSharedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SharedNotebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "sharedNotebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sharedNotebook: %s", p, err)
		}
		if err := p.SharedNotebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SharedNotebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:sharedNotebook: %s", p, err)
		}
	}
	return err
}

func (p *CreateSharedNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateSharedNotebookArgs(%+v)", *p)
}

type CreateSharedNotebookResult struct {
	Success           *Types.SharedNotebook         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewCreateSharedNotebookResult() *CreateSharedNotebookResult {
	return &CreateSharedNotebookResult{}
}

func (p *CreateSharedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateSharedNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewSharedNotebook()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CreateSharedNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CreateSharedNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *CreateSharedNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CreateSharedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createSharedNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateSharedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateSharedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CreateSharedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *CreateSharedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CreateSharedNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateSharedNotebookResult(%+v)", *p)
}

type UpdateSharedNotebookArgs struct {
	AuthenticationToken string                `thrift:"authenticationToken,1"`
	SharedNotebook      *Types.SharedNotebook `thrift:"sharedNotebook,2"`
}

func NewUpdateSharedNotebookArgs() *UpdateSharedNotebookArgs {
	return &UpdateSharedNotebookArgs{}
}

func (p *UpdateSharedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateSharedNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateSharedNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SharedNotebook = Types.NewSharedNotebook()
	if err := p.SharedNotebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SharedNotebook)
	}
	return nil
}

func (p *UpdateSharedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateSharedNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateSharedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateSharedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SharedNotebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "sharedNotebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sharedNotebook: %s", p, err)
		}
		if err := p.SharedNotebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SharedNotebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:sharedNotebook: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSharedNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateSharedNotebookArgs(%+v)", *p)
}

type UpdateSharedNotebookResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewUpdateSharedNotebookResult() *UpdateSharedNotebookResult {
	return &UpdateSharedNotebookResult{}
}

func (p *UpdateSharedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateSharedNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UpdateSharedNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateSharedNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateSharedNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateSharedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateSharedNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateSharedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UpdateSharedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSharedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSharedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateSharedNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateSharedNotebookResult(%+v)", *p)
}

type SetSharedNotebookRecipientSettingsArgs struct {
	AuthenticationToken string                                 `thrift:"authenticationToken,1"`
	SharedNotebookId    int64                                  `thrift:"sharedNotebookId,2"`
	RecipientSettings   *Types.SharedNotebookRecipientSettings `thrift:"recipientSettings,3"`
}

func NewSetSharedNotebookRecipientSettingsArgs() *SetSharedNotebookRecipientSettingsArgs {
	return &SetSharedNotebookRecipientSettingsArgs{}
}

func (p *SetSharedNotebookRecipientSettingsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.SharedNotebookId = v
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.RecipientSettings = Types.NewSharedNotebookRecipientSettings()
	if err := p.RecipientSettings.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RecipientSettings)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setSharedNotebookRecipientSettings_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *SetSharedNotebookRecipientSettingsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sharedNotebookId", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:sharedNotebookId: %s", p, err)
	}
	if err := oprot.WriteI64(ctx, int64(p.SharedNotebookId)); err != nil {
		return fmt.Errorf("%T.sharedNotebookId (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:sharedNotebookId: %s", p, err)
	}
	return err
}

func (p *SetSharedNotebookRecipientSettingsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.RecipientSettings != nil {
		if err := oprot.WriteFieldBegin(ctx, "recipientSettings", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:recipientSettings: %s", p, err)
		}
		if err := p.RecipientSettings.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.RecipientSettings)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:recipientSettings: %s", p, err)
		}
	}
	return err
}

func (p *SetSharedNotebookRecipientSettingsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetSharedNotebookRecipientSettingsArgs(%+v)", *p)
}

type SetSharedNotebookRecipientSettingsResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewSetSharedNotebookRecipientSettingsResult() *SetSharedNotebookRecipientSettingsResult {
	return &SetSharedNotebookRecipientSettingsResult{}
}

func (p *SetSharedNotebookRecipientSettingsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setSharedNotebookRecipientSettings_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetSharedNotebookRecipientSettingsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SetSharedNotebookRecipientSettingsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *SetSharedNotebookRecipientSettingsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *SetSharedNotebookRecipientSettingsResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *SetSharedNotebookRecipientSettingsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetSharedNotebookRecipientSettingsResult(%+v)", *p)
}

type SendMessageToSharedNotebookMembersArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	NotebookGuid        Types.Guid `thrift:"notebookGuid,2"`
	MessageText         string     `thrift:"messageText,3"`
	Recipients          []string   `thrift:"recipients,4"`
}

func NewSendMessageToSharedNotebookMembersArgs() *SendMessageToSharedNotebookMembersArgs {
	return &SendMessageToSharedNotebookMembersArgs{}
}

func (p *SendMessageToSharedNotebookMembersArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NotebookGuid = Types.Guid(v)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.MessageText = v
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersArgs) readField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Recipients = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem338 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem338 = v
		}
		p.Recipients = append(p.Recipients, _elem338)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sendMessageToSharedNotebookMembers_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField4(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:notebookGuid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.NotebookGuid)); err != nil {
		return fmt.Errorf("%T.notebookGuid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:notebookGuid: %s", p, err)
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "messageText", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:messageText: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.MessageText)); err != nil {
		return fmt.Errorf("%T.messageText (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:messageText: %s", p, err)
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Recipients != nil {
		if err := oprot.WriteFieldBegin(ctx, "recipients", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:recipients: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Recipients)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Recipients {
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 4:recipients: %s", p, err)
		}
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SendMessageToSharedNotebookMembersArgs(%+v)", *p)
}

type SendMessageToSharedNotebookMembersResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewSendMessageToSharedNotebookMembersResult() *SendMessageToSharedNotebookMembersResult {
	return &SendMessageToSharedNotebookMembersResult{}
}

func (p *SendMessageToSharedNotebookMembersResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sendMessageToSharedNotebookMembers_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SendMessageToSharedNotebookMembersResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *SendMessageToSharedNotebookMembersResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SendMessageToSharedNotebookMembersResult(%+v)", *p)
}

type ListSharedNotebooksArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewListSharedNotebooksArgs() *ListSharedNotebooksArgs {
	return &ListSharedNotebooksArgs{}
}

func (p *ListSharedNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListSharedNotebooksArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListSharedNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listSharedNotebooks_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListSharedNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListSharedNotebooksArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListSharedNotebooksArgs(%+v)", *p)
}

type ListSharedNotebooksResult struct {
	Success           []*Types.SharedNotebook       `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewListSharedNotebooksResult() *ListSharedNotebooksResult {
	return &ListSharedNotebooksResult{}
}

func (p *ListSharedNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListSharedNotebooksResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Types.SharedNotebook, 0, size)
	for i := 0; i < size; i++ {
		_elem339 := Types.NewSharedNotebook()
		if err := _elem339.Read(ctx, iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem339)
		}
		p.Success = append(p.Success, _elem339)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListSharedNotebooksResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListSharedNotebooksResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ListSharedNotebooksResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListSharedNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listSharedNotebooks_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListSharedNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListSharedNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListSharedNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ListSharedNotebooksResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListSharedNotebooksResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListSharedNotebooksResult(%+v)", *p)
}

type ExpungeSharedNotebooksArgs struct {
	AuthenticationToken string  `thrift:"authenticationToken,1"`
	SharedNotebookIds   []int64 `thrift:"sharedNotebookIds,2"`
}

func NewExpungeSharedNotebooksArgs() *ExpungeSharedNotebooksArgs {
	return &ExpungeSharedNotebooksArgs{}
}

func (p *ExpungeSharedNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeSharedNotebooksArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeSharedNotebooksArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.SharedNotebookIds = make([]int64, 0, size)
	for i := 0; i < size; i++ {
		var _elem340 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem340 = v
		}
		p.SharedNotebookIds = append(p.SharedNotebookIds, _elem340)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ExpungeSharedNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeSharedNotebooks_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeSharedNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeSharedNotebooksArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SharedNotebookIds != nil {
		if err := oprot.WriteFieldBegin(ctx, "sharedNotebookIds", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sharedNotebookIds: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.SharedNotebookIds)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.SharedNotebookIds {
			if err := oprot.WriteI64(ctx, int64(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:sharedNotebookIds: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeSharedNotebooksArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeSharedNotebooksArgs(%+v)", *p)
}

type ExpungeSharedNotebooksResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewExpungeSharedNotebooksResult() *ExpungeSharedNotebooksResult {
	return &ExpungeSharedNotebooksResult{}
}

func (p *ExpungeSharedNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeSharedNotebooksResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeSharedNotebooksResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeSharedNotebooksResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ExpungeSharedNotebooksResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeSharedNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeSharedNotebooks_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeSharedNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeSharedNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeSharedNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeSharedNotebooksResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeSharedNotebooksResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeSharedNotebooksResult(%+v)", *p)
}

type CreateLinkedNotebookArgs struct {
	AuthenticationToken string                `thrift:"authenticationToken,1"`
	LinkedNotebook      *Types.LinkedNotebook `thrift:"linkedNotebook,2"`
}

func NewCreateLinkedNotebookArgs() *CreateLinkedNotebookArgs {
	return &CreateLinkedNotebookArgs{}
}

func (p *CreateLinkedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateLinkedNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CreateLinkedNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.LinkedNotebook = Types.NewLinkedNotebook()
	if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LinkedNotebook)
	}
	return nil
}

func (p *CreateLinkedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createLinkedNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateLinkedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CreateLinkedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.LinkedNotebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:linkedNotebook: %s", p, err)
		}
		if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.LinkedNotebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:linkedNotebook: %s", p, err)
		}
	}
	return err
}

func (p *CreateLinkedNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateLinkedNotebookArgs(%+v)", *p)
}

type CreateLinkedNotebookResult struct {
	Success           *Types.LinkedNotebook         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewCreateLinkedNotebookResult() *CreateLinkedNotebookResult {
	return &CreateLinkedNotebookResult{}
}

func (p *CreateLinkedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateLinkedNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewLinkedNotebook()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CreateLinkedNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CreateLinkedNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *CreateLinkedNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CreateLinkedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createLinkedNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateLinkedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateLinkedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CreateLinkedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *CreateLinkedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CreateLinkedNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateLinkedNotebookResult(%+v)", *p)
}

type UpdateLinkedNotebookArgs struct {
	AuthenticationToken string                `thrift:"authenticationToken,1"`
	LinkedNotebook      *Types.LinkedNotebook `thrift:"linkedNotebook,2"`
}

func NewUpdateLinkedNotebookArgs() *UpdateLinkedNotebookArgs {
	return &UpdateLinkedNotebookArgs{}
}

func (p *UpdateLinkedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateLinkedNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateLinkedNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.LinkedNotebook = Types.NewLinkedNotebook()
	if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LinkedNotebook)
	}
	return nil
}

func (p *UpdateLinkedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateLinkedNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateLinkedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateLinkedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.LinkedNotebook != nil {
		if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:linkedNotebook: %s", p, err)
		}
		if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.LinkedNotebook)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:linkedNotebook: %s", p, err)
		}
	}
	return err
}

func (p *UpdateLinkedNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateLinkedNotebookArgs(%+v)", *p)
}

type UpdateLinkedNotebookResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewUpdateLinkedNotebookResult() *UpdateLinkedNotebookResult {
	return &UpdateLinkedNotebookResult{}
}

func (p *UpdateLinkedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateLinkedNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *UpdateLinkedNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateLinkedNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateLinkedNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateLinkedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updateLinkedNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateLinkedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *UpdateLinkedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateLinkedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateLinkedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateLinkedNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateLinkedNotebookResult(%+v)", *p)
}

type ListLinkedNotebooksArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewListLinkedNotebooksArgs() *ListLinkedNotebooksArgs {
	return &ListLinkedNotebooksArgs{}
}

func (p *ListLinkedNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListLinkedNotebooksArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListLinkedNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listLinkedNotebooks_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListLinkedNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListLinkedNotebooksArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListLinkedNotebooksArgs(%+v)", *p)
}

type ListLinkedNotebooksResult struct {
	Success           []*Types.LinkedNotebook       `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewListLinkedNotebooksResult() *ListLinkedNotebooksResult {
	return &ListLinkedNotebooksResult{}
}

func (p *ListLinkedNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListLinkedNotebooksResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Types.LinkedNotebook, 0, size)
	for i := 0; i < size; i++ {
		_elem341 := Types.NewLinkedNotebook()
		if err := _elem341.Read(ctx, iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem341)
		}
		p.Success = append(p.Success, _elem341)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListLinkedNotebooksResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListLinkedNotebooksResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ListLinkedNotebooksResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListLinkedNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "listLinkedNotebooks_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListLinkedNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListLinkedNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListLinkedNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ListLinkedNotebooksResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListLinkedNotebooksResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListLinkedNotebooksResult(%+v)", *p)
}

type ExpungeLinkedNotebookArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewExpungeLinkedNotebookArgs() *ExpungeLinkedNotebookArgs {
	return &ExpungeLinkedNotebookArgs{}
}

func (p *ExpungeLinkedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeLinkedNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ExpungeLinkedNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *ExpungeLinkedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeLinkedNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeLinkedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ExpungeLinkedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *ExpungeLinkedNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeLinkedNotebookArgs(%+v)", *p)
}

type ExpungeLinkedNotebookResult struct {
	Success           int32                         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewExpungeLinkedNotebookResult() *ExpungeLinkedNotebookResult {
	return &ExpungeLinkedNotebookResult{}
}

func (p *ExpungeLinkedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExpungeLinkedNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExpungeLinkedNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ExpungeLinkedNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ExpungeLinkedNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ExpungeLinkedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "expungeLinkedNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExpungeLinkedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExpungeLinkedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeLinkedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeLinkedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ExpungeLinkedNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExpungeLinkedNotebookResult(%+v)", *p)
}

type AuthenticateToSharedNotebookArgs struct {
	ShareKey            string `thrift:"shareKey,1"`
	AuthenticationToken string `thrift:"authenticationToken,2"`
}

func NewAuthenticateToSharedNotebookArgs() *AuthenticateToSharedNotebookArgs {
	return &AuthenticateToSharedNotebookArgs{}
}

func (p *AuthenticateToSharedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ShareKey = v
	}
	return nil
}

func (p *AuthenticateToSharedNotebookArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *AuthenticateToSharedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNotebook_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "shareKey", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:shareKey: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.ShareKey)); err != nil {
		return fmt.Errorf("%T.shareKey (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:shareKey: %s", p, err)
	}
	return err
}

func (p *AuthenticateToSharedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:authenticationToken: %s", p, err)
	}
	return err
}

func (p *AuthenticateToSharedNotebookArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToSharedNotebookArgs(%+v)", *p)
}

type AuthenticateToSharedNotebookResult struct {
	Success           *UserStore.AuthenticationResult `thrift:"success,0"`
	UserException     *Errors.EDAMUserException       `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException   `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException     `thrift:"systemException,3"`
}

func NewAuthenticateToSharedNotebookResult() *AuthenticateToSharedNotebookResult {
	return &AuthenticateToSharedNotebookResult{}
}

func (p *AuthenticateToSharedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = UserStore.NewAuthenticationResult()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNotebook_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToSharedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNotebookResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToSharedNotebookResult(%+v)", *p)
}

type GetSharedNotebookByAuthArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetSharedNotebookByAuthArgs() *GetSharedNotebookByAuthArgs {
	return &GetSharedNotebookByAuthArgs{}
}

func (p *GetSharedNotebookByAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSharedNotebookByAuthArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetSharedNotebookByAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSharedNotebookByAuth_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSharedNotebookByAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetSharedNotebookByAuthArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSharedNotebookByAuthArgs(%+v)", *p)
}

type GetSharedNotebookByAuthResult struct {
	Success           *Types.SharedNotebook         `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewGetSharedNotebookByAuthResult() *GetSharedNotebookByAuthResult {
	return &GetSharedNotebookByAuthResult{}
}

func (p *GetSharedNotebookByAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSharedNotebookByAuthResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = Types.NewSharedNotebook()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetSharedNotebookByAuthResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetSharedNotebookByAuthResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetSharedNotebookByAuthResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetSharedNotebookByAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getSharedNotebookByAuth_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSharedNotebookByAuthResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSharedNotebookByAuthResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetSharedNotebookByAuthResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetSharedNotebookByAuthResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetSharedNotebookByAuthResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSharedNotebookByAuthResult(%+v)", *p)
}

type EmailNoteArgs struct {
	AuthenticationToken string               `thrift:"authenticationToken,1"`
	Parameters          *NoteEmailParameters `thrift:"parameters,2"`
}

func NewEmailNoteArgs() *EmailNoteArgs {
	return &EmailNoteArgs{}
}

func (p *EmailNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EmailNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *EmailNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Parameters = NewNoteEmailParameters()
	if err := p.Parameters.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Parameters)
	}
	return nil
}

func (p *EmailNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "emailNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EmailNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *EmailNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Parameters != nil {
		if err := oprot.WriteFieldBegin(ctx, "parameters", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:parameters: %s", p, err)
		}
		if err := p.Parameters.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Parameters)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:parameters: %s", p, err)
		}
	}
	return err
}

func (p *EmailNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EmailNoteArgs(%+v)", *p)
}

type EmailNoteResult struct {
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewEmailNoteResult() *EmailNoteResult {
	return &EmailNoteResult{}
}

func (p *EmailNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EmailNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *EmailNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *EmailNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *EmailNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "emailNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EmailNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *EmailNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *EmailNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *EmailNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EmailNoteResult(%+v)", *p)
}

type ShareNoteArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewShareNoteArgs() *ShareNoteArgs {
	return &ShareNoteArgs{}
}

func (p *ShareNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ShareNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ShareNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *ShareNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "shareNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ShareNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ShareNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *ShareNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ShareNoteArgs(%+v)", *p)
}

type ShareNoteResult struct {
	Success           string                        `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewShareNoteResult() *ShareNoteResult {
	return &ShareNoteResult{}
}

func (p *ShareNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ShareNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ShareNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ShareNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *ShareNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ShareNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "shareNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ShareNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ShareNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ShareNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *ShareNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ShareNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ShareNoteResult(%+v)", *p)
}

type StopSharingNoteArgs struct {
	AuthenticationToken string     `thrift:"authenticationToken,1"`
	Guid                Types.Guid `thrift:"guid,2"`
}

func NewStopSharingNoteArgs() *StopSharingNoteArgs {
	return &StopSharingNoteArgs{}
}

func (p *StopSharingNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *StopSharingNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *StopSharingNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Guid = Types.Guid(v)
	}
	return nil
}

func (p *StopSharingNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "stopSharingNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *StopSharingNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *StopSharingNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:guid: %s", p, err)
	}
	return err
}

func (p *StopSharingNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StopSharingNoteArgs(%+v)", *p)
}

type StopSharingNoteResult struct {
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,3"`
}

func NewStopSharingNoteResult() *StopSharingNoteResult {
	return &StopSharingNoteResult{}
}

func (p *StopSharingNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *StopSharingNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *StopSharingNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *StopSharingNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *StopSharingNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "stopSharingNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *StopSharingNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *StopSharingNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *StopSharingNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *StopSharingNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StopSharingNoteResult(%+v)", *p)
}

type AuthenticateToSharedNoteArgs struct {
	Guid                string `thrift:"guid,1"`
	NoteKey             string `thrift:"noteKey,2"`
	AuthenticationToken string `thrift:"authenticationToken,3"`
}

func NewAuthenticateToSharedNoteArgs() *AuthenticateToSharedNoteArgs {
	return &AuthenticateToSharedNoteArgs{}
}

func (p *AuthenticateToSharedNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToSharedNoteArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Guid = v
	}
	return nil
}

func (p *AuthenticateToSharedNoteArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NoteKey = v
	}
	return nil
}

func (p *AuthenticateToSharedNoteArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *AuthenticateToSharedNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNote_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToSharedNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:guid: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.Guid)); err != nil {
		return fmt.Errorf("%T.guid (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:guid: %s", p, err)
	}
	return err
}

func (p *AuthenticateToSharedNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "noteKey", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:noteKey: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.NoteKey)); err != nil {
		return fmt.Errorf("%T.noteKey (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 2:noteKey: %s", p, err)
	}
	return err
}

func (p *AuthenticateToSharedNoteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 3:authenticationToken: %s", p, err)
	}
	return err
}

func (p *AuthenticateToSharedNoteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToSharedNoteArgs(%+v)", *p)
}

type AuthenticateToSharedNoteResult struct {
	Success           *UserStore.AuthenticationResult `thrift:"success,0"`
	UserException     *Errors.EDAMUserException       `thrift:"userException,1"`
	NotFoundException *Errors.EDAMNotFoundException   `thrift:"notFoundException,2"`
	SystemException   *Errors.EDAMSystemException     `thrift:"systemException,3"`
}

func NewAuthenticateToSharedNoteResult() *AuthenticateToSharedNoteResult {
	return &AuthenticateToSharedNoteResult{}
}

func (p *AuthenticateToSharedNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToSharedNoteResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = UserStore.NewAuthenticationResult()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *AuthenticateToSharedNoteResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *AuthenticateToSharedNoteResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *AuthenticateToSharedNoteResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *AuthenticateToSharedNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNote_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToSharedNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:systemException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToSharedNoteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToSharedNoteResult(%+v)", *p)
}

type FindRelatedArgs struct {
	AuthenticationToken string             `thrift:"authenticationToken,1"`
	Query               *RelatedQuery      `thrift:"query,2"`
	ResultSpec          *RelatedResultSpec `thrift:"resultSpec,3"`
}

func NewFindRelatedArgs() *FindRelatedArgs {
	return &FindRelatedArgs{}
}

func (p *FindRelatedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindRelatedArgs) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *FindRelatedArgs) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Query = NewRelatedQuery()
	if err := p.Query.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Query)
	}
	return nil
}

func (p *FindRelatedArgs) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.ResultSpec = NewRelatedResultSpec()
	if err := p.ResultSpec.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ResultSpec)
	}
	return nil
}

func (p *FindRelatedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findRelated_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField2(ctx, oprot); err != nil {
		return err
	}
	if err := p.writeField3(ctx, oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindRelatedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *FindRelatedArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Query != nil {
		if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:query: %s", p, err)
		}
		if err := p.Query.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Query)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:query: %s", p, err)
		}
	}
	return err
}

func (p *FindRelatedArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.ResultSpec != nil {
		if err := oprot.WriteFieldBegin(ctx, "resultSpec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:resultSpec: %s", p, err)
		}
		if err := p.ResultSpec.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ResultSpec)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:resultSpec: %s", p, err)
		}
	}
	return err
}

func (p *FindRelatedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindRelatedArgs(%+v)", *p)
}

type FindRelatedResult struct {
	Success           *RelatedResult                `thrift:"success,0"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewFindRelatedResult() *FindRelatedResult {
	return &FindRelatedResult{}
}

func (p *FindRelatedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(ctx, iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(ctx, iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(ctx, iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(ctx, iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FindRelatedResult) readField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = NewRelatedResult()
	if err := p.Success.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *FindRelatedResult) readField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *FindRelatedResult) readField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *FindRelatedResult) readField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(ctx, iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *FindRelatedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "findRelated_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FindRelatedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FindRelatedResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *FindRelatedResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *FindRelatedResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(ctx, oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *FindRelatedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FindRelatedResult(%+v)", *p)
}
